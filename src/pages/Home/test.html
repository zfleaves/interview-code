<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="content_views" class="htmledit_views">
        <p id="main-toc"><strong>目录</strong></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t0" rel="nofollow"
                target="_self">一、HTML篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%911.%20HTML5%20%E6%96%B0%E5%A2%9E%E9%82%A3%E4%BA%9B%E6%A0%87%E7%AD%BE%3F"
                rel="nofollow" target="_self">1、HTML5 新增那些标签?</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%913.%20%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%97%E7%BA%A7%E6%A0%87%E7%AD%BE%E5%92%8C%E8%A1%8C%E5%86%85%E6%A0%87%E7%AD%BE%EF%BC%9F"
                rel="nofollow" target="_self">2、常见的块元素、行内元素以及行内块元素，三者有何不同？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%914.%20%E7%AE%80%E8%BF%B0%20readyonly%20%E4%B8%8E%20disabled%20%E7%9A%84%E5%8C%BA%E5%88%AB"
                rel="nofollow" target="_self">3、HTML、XML、XHTML它们之间有什么区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%915.%20HTML5%20%E7%9A%84%E7%BD%91%E9%A1%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99%3C!DOCTYOE%20HTML%3E%3F"
                rel="nofollow" target="_self">4、DOCTYPE(⽂档类型) 的作⽤</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%916.HTML5%20%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">5、localStorage、sessionStorage、cookie 三者明细区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%917.%E7%BD%91%E7%AB%99TDK%E4%B8%89%E5%A4%A7%E6%A0%87%E7%AD%BESEO%E4%BC%98%E5%8C%96%C2%A0"
                rel="nofollow" target="_self">6、网站TDK三大标签以及SEO优化&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#7%E3%80%81%E6%A0%87%E7%AD%BE%E4%B8%8Atitle%E5%B1%9E%E6%80%A7%E4%B8%8Ealt%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"
                rel="nofollow" target="_self">7、img标签的title属性与alt属性的区别是什么？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#8%E3%80%81src%20%E5%92%8C%20href%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow"
                target="_self">8、src 和 href 的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#9%E3%80%81title%20%E4%B8%8E%20h1%20%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%20%E4%B8%8E%20strong%20%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%20%E4%B8%8E%20em%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">9、title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#8%E3%80%81iframe%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%20%EF%BC%9F"
                rel="nofollow" target="_self">10、iframe的优点和缺点 ？</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t1" rel="nofollow"
                target="_self">二、CSS篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%911.%E7%AE%80%E6%98%8E%E8%AF%B4%E4%B8%80%E4%B8%8B%20CSS%20link%20%E4%B8%8E%20%40import%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95%EF%BC%9F"
                rel="nofollow" target="_self">1、说一下 link 与 @import 的区别和用法？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%912.rgba%E5%92%8Copacity%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"
                rel="nofollow" target="_self">2、rgba和opacity的透明效果有什么不同？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%913.%20display%3Anone%E5%92%8Cvisibility%3Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">3、display:none与visibility:hidden的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A0%E2%80%8B%E7%BC%96%E8%BE%914.%E5%87%A0%E7%A7%8D%E5%AE%9A%E4%BD%8D%E5%B8%83%E5%B1%80%20position%E7%9A%84%E5%80%BC%EF%BC%8C%20relative%E5%92%8Cabsolute%E5%88%86%E5%88%AB%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E8%B0%81%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%E7%9A%84%EF%BC%9F"
                rel="nofollow" target="_self">4、定位布局 position中的relative、absolute、fixed、sticky它们之间的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%91%C2%A05.%20%E7%94%A8CSS3%E7%94%BB%E4%B8%80%E6%9D%A10.5px%E7%9A%84%E7%9B%B4%E7%BA%BF%EF%BC%9F"
                rel="nofollow" target="_self">5、如何用CSS3画一条0.5px的直线？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A06.%20%E7%94%A8CSS3%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%9F"
                rel="nofollow" target="_self">6、如何用CSS3画一个三角形？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%917.CSS3%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B" rel="nofollow"
                target="_self">7、CSS3盒子模型：标准盒模型、怪异盒模型</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#8.%E6%B5%AE%E5%8A%A8%EF%BC%88float%29"
                rel="nofollow" target="_self">8、浮动（float)以及清除浮动的方法</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%919%E3%80%81Flex%E5%B8%83%E5%B1%80" rel="nofollow"
                target="_self">9、Flex布局</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9110%E3%80%81CSS%E5%B9%B3%E9%9D%A2%E8%BD%AC%E6%8D%A2" rel="nofollow"
                target="_self">10、CSS3中“transform”属性~平面转换</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9111%E3%80%81CSS%E4%B8%AD%E7%9A%84%E2%80%9C%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8%E2%80%9D"
                rel="nofollow" target="_self">11、CSS3中 “子绝父相” 定位布局</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9112%E3%80%81CSS3%E4%B8%AD%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD"
                rel="nofollow" target="_self">12、盒子居中的几种方法：“子绝父相”、“Flex布局”、“transform”</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9113%E3%80%81CSS3%E4%B8%AD%E5%AE%9A%E4%BD%8D%E5%8F%A0%E6%94%BE%E6%AC%A1%E5%BA%8F%20z-index"
                rel="nofollow" target="_self">13、CSS3中有哪些新特性？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A0%E2%80%8B%E7%BC%96%E8%BE%9114%E3%80%81CSS3%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D"
                rel="nofollow" target="_self">14、CSS3选择器及其优先级</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9115%E3%80%81CSS3%E4%B8%AD%E8%BF%87%E6%B8%A1" rel="nofollow"
                target="_self">15、CSS3中 “transition”&nbsp;过渡属性</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9116%E3%80%81CSS3%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8"
                rel="nofollow" target="_self">16、结构伪类选择器&amp;伪元素选择器</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#17%E3%80%81display%E7%9A%84block%E3%80%81inline%E5%92%8Cinline-block%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">17、display的block、inline和inline-block的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#18%E3%80%81%E5%AE%9A%E4%BD%8D%E5%A0%86%E5%8F%A0%E9%A1%BA%E5%BA%8Fz-index" rel="nofollow"
                target="_self">18、定位堆叠顺序z-index</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t2" rel="nofollow"
                target="_self">三、HTML&amp;&amp;CSS混合篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%20Localstorage%E3%80%81sessionStorage%E3%80%81cookie%20%E7%9A%84%E5%8C%BA%E5%88%AB"
                rel="nofollow" target="_self">1、Localstorage、sessionStorage、cookie 的区别</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%912%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E9%A3%9E%E7%BF%BC%EF%BC%88%E5%9C%A3%E6%9D%AF%EF%BC%89%E5%B8%83%E5%B1%80%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">2、如何实现双飞翼（圣杯）布局？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%3A%3Abefore%20%E5%92%8C%3A%3Aafter%20%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%81%E4%BD%9C%E7%94%A8%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">3、伪元素和伪类的区别和作用？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%914%E3%80%81img%20%E7%9A%84%20alt%20%E4%B8%8E%20title%20%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%8C%E8%BF%98%E6%9C%89%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F"
                rel="nofollow" target="_self">4、img 的 alt 与 title 的异同，还有实现图片懒加载的原理？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%915%E3%80%81BFC%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">5、BFC 是什么？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t3" rel="nofollow"
                target="_self">四、JavaScript篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%20JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B" rel="nofollow"
                target="_self">1、JS基础类型和复杂类型</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">2、箭头函数与普通函数的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%872.JS%E4%B8%ADnull%E5%92%8Cundefined%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">3、JS中null和undefined的判断方法和区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%873%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE" rel="nofollow" target="_self">4、原型链</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A0%F0%9F%8D%874%E3%80%81v-show%20%E4%B8%8E%20v-if%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">5、v-show 与 v-if 的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%875%E3%80%81keep-alive%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%3F"
                rel="nofollow" target="_self">6、keep-alive 的作用是什么?</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%876%E3%80%81%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%3F" rel="nofollow"
                target="_self">7、闭包的理解?</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#8%E3%80%81JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" rel="nofollow"
                target="_self">8、JS垃圾回收机制</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%878%E3%80%81nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow"
                target="_self">9、nextTick的实现？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%879%E3%80%81mixin%E5%8E%9F%E7%90%86" rel="nofollow" target="_self">10、混入mixin的原理？</a>
        </p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9110%E3%80%81%E5%88%97%E4%B8%BE%E5%92%8C%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95"
                rel="nofollow" target="_self">11、列举和数组操作相关的方法</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9111%E3%80%81%C2%A0typeof%E5%92%8Cinstanceof%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">12、typeof和instanceof的区别是什么？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9112%E3%80%81js%E4%B8%AD%E2%80%9C%3D%3D%3D%E2%80%9D%20%E5%92%8C%20%E2%80%9C%3D%3D%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">13、JS中 “==“和“===“的区别详解</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A0%E2%80%8B%E7%BC%96%E8%BE%9113%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%20JavaScript%20%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AA%20onclick%20%E4%BA%8B%E4%BB%B6%EF%BC%9F"
                rel="nofollow" target="_self">14、如何用原生 JS给一个按钮绑定两个 onclick 事件？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9114%E3%80%81var%20let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">15、var、let和const的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9115%E3%80%81%E8%AE%B2%E8%A7%A3js%E7%9A%84call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">16、讲解js的call、apply和bind区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%9116%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F"
                rel="nofollow" target="_self">17、谈谈你对webpack的理解？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#17%E3%80%81%C2%A0const%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%EF%BC%9F"
                rel="nofollow" target="_self">18、&nbsp;const定义的对象属性是否可以改变？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A018%E3%80%81%E6%89%93%E5%8D%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%8C%E5%87%BA%E7%8E%B0%E6%A0%88%E6%BA%A2%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F"
                rel="nofollow" target="_self">19、栈溢出及解决方法？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#20%E3%80%81JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"
                rel="nofollow" target="_self">20、JS如何实现多线程？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#21%E3%80%81%C2%A0%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%A6%82%E5%BF%B5%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%EF%BC%9F"
                rel="nofollow" target="_self">21、浅拷贝和深拷贝区别概念常见情况？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#22%E3%80%81promise%E5%92%8Casync%EF%BC%8Cawait%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">22、事件循环，Promise和async/await的详解</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#23%E3%80%81JS%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%C2%A0"
                rel="nofollow" target="_self">23、JS中数组常用方法详解&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t4" rel="nofollow"
                target="_self">五、Vue2篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%877%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%3F%E6%AF%94%E5%A6%82%EF%BC%88Vue2%E7%9A%84webpack%EF%BC%8CVue3%E7%9A%84Vite%EF%BC%89"
                rel="nofollow" target="_self">&ZeroWidthSpace;1、什么是前端构建工具?比如（Vue2的webpack，Vue3的Vite）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%8710%E3%80%81Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F"
                rel="nofollow" target="_self">&ZeroWidthSpace;2、Vue 组件之间的通信方式</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%F0%9F%8D%8711%E3%80%81Vuex%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"
                rel="nofollow" target="_self">&ZeroWidthSpace;3、Vuex的理解及使用场景</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A0%E2%80%8B%E7%BC%96%E8%BE%914%E3%80%81vue%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%C2%A0%E5%85%AB%E4%B8%AA%E9%98%B6%E6%AE%B5"
                rel="nofollow" target="_self">4、vue 的生命周期&nbsp;八个阶段</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#5%E3%80%81%E7%AE%80%E8%BF%B0Vue%E6%AF%8F%E4%B8%AA%E5%91%A8%E6%9C%9F%E5%85%B7%E4%BD%93%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F"
                rel="nofollow" target="_self">5、简述Vue每个周期具体适合哪些场景？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%915%E3%80%81%E7%AE%80%E8%BF%B0MVVM" rel="nofollow"
                target="_self">6、简述MVVM 和MVC的原理以及区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%916%E3%80%81vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4" rel="nofollow"
                target="_self">7、vue常见指令</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%917%E3%80%81vue%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F%E8%B5%B7%E5%88%B0%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">8、vue中的data为什么是一个函数？起到什么作用？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%E2%80%8B%E7%BC%96%E8%BE%918%E3%80%81vue%E4%B8%ADref%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%C2%A0%C2%A0"
                rel="nofollow" target="_self">9、vue中ref的作用？&nbsp;&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#10%E3%80%81vue%E4%B8%ADhash%E5%92%8Chistory%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0%EF%BC%9F%C2%A0%C2%A0"
                rel="nofollow" target="_self">10、vue中hash和history的区别&nbsp;？&nbsp;&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t5" rel="nofollow"
                target="_self">六&nbsp;、Vue3篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#1%E3%80%81Vue2.0%E5%92%8CVue3.0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow"
                target="_self">1、Vue2.0和Vue3.0的区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#2%E3%80%81Vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88%E6%94%B9%E5%8F%98%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">2、Vue3带来了什么改变？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#3%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88vue2%E5%92%8Cvue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AF%B9%E6%AF%94%EF%BC%89%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"
                rel="nofollow" target="_self">3、生命周期（vue2和vue3的生命周期对比）有哪些？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#4%E3%80%81Vue3.0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fvue2%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"
                rel="nofollow" target="_self">4、Vue3.0中的响应式原理是什么？vue2的响应式原理是什么？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#5%E3%80%81vue3%E7%9A%84%E5%B8%B8%E7%94%A8%20Composition%20API%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"
                rel="nofollow" target="_self">5、vue3的常用 Composition API有哪些？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#%C2%A06%E3%80%81ref%E5%87%BD%E6%95%B0"
                rel="nofollow" target="_self">6、Vue3中的ref函数</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t6" rel="nofollow"
                target="_self">七、React篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#1%E3%80%81%E8%AE%B2%E8%AE%B2%E4%BB%80%E4%B9%88%E6%98%AF%20JSX%20%EF%BC%9F" rel="nofollow"
                target="_self">1、讲讲什么是 JSX ？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#2%E3%80%81React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"
                rel="nofollow" target="_self">2、React 的生命周期方法有哪些？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#t7" rel="nofollow"
                target="_self">3、React的Hooks详解</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#4%E3%80%81React%E5%92%8CVue.js%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%92%8C%E5%B7%AE%E5%BC%82%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"
                rel="nofollow" target="_self">4、React和Vue.js的相似性和差异性是什么？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#5%E3%80%81React%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">5、React的功能是什么？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#6%E3%80%81React%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%E6%98%AF%EF%BC%9F"
                rel="nofollow" target="_self">6、React的一些主要优点是？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#7.%20React%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"
                rel="nofollow" target="_self">7、React的局限性是什么？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#8%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3React%20State%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E7%9A%84%E5%8E%9F%E5%88%99"
                rel="nofollow" target="_self">8、如何理解React State不可变性的原则</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#9%E3%80%81React%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%85%B3%E9%94%AE%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB%EF%BC%9F"
                rel="nofollow" target="_self">9、React的特点和关键版本区别？</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t8" rel="nofollow"
                target="_self">八、uniapp篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#1%E3%80%81uniapp%E4%BC%98%E7%BC%BA%E7%82%B9" rel="nofollow" target="_self">1、uniapp优缺点</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#2%E3%80%81uniapp%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" rel="nofollow"
                target="_self">2、uniapp目录结构</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#3%E3%80%81%E8%B7%A8%E7%AB%AF%E9%80%82%E9%85%8D%E2%80%94%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91%C2%A0"
                rel="nofollow" target="_self">3、跨端适配—条件编译&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#%C2%A04%E3%80%81uniapp%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5"
                rel="nofollow" target="_self">4、uniapp 常用的指令语句</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#5%E3%80%81uniapp%20%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"
                rel="nofollow" target="_self">5、uniapp 应用的生命周期、页面的生命周期、组件的生命周期</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t9" rel="nofollow"
                target="_self">九、Webpack篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#1.Webpack%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow" target="_self">1、Webpack是什么？</a>
        </p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#2%E3%80%81Webpack%E7%9A%84%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%2F%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%2F%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">2、Webpack的打包过程/打包原理/构建流程？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#3%E3%80%81Webpack%E4%B8%ADloader%E7%9A%84%E4%BD%9C%E7%94%A8%2F%20loader%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"
                rel="nofollow" target="_self">3、Webpack中loader的作用/ loader是什么？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#4%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84loader%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow"
                target="_self">4、常见的loader有哪些？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#5%E3%80%81Plugin%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9FPlugin%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"
                rel="nofollow" target="_self">5、Plugin有什么作用？Plugin是什么？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#6%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84Plugin%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F" rel="nofollow"
                target="_self">6、常见的Plugin有哪些？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#7%E3%80%81Webpack%E4%B8%ADLoader%E5%92%8CPlugin%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow"
                target="_self">7、Webpack中Loader和Plugin的区别</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#8%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F"
                rel="nofollow" target="_self">8、如何利用webpack来优化前端性能？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#9%E3%80%81Webpack%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81%EF%BC%9F%E5%8E%8B%E7%BC%A9%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"
                rel="nofollow" target="_self">9、Webpack如何配置压缩代码？压缩了什么？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#10%E3%80%81%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%EF%BC%9F%C2%A0"
                rel="nofollow" target="_self">10、如何提高webpack的构建速度？&nbsp;</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t10" rel="nofollow"
                target="_self">十、Git/SVN篇</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#1%E3%80%81Git%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow" target="_self">1、Git是什么？</a>
        </p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#2%E3%80%81%E7%AE%80%E8%BF%B0git%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A2%9E%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%9F"
                rel="nofollow" target="_self">2、简述Git中如何将一个新增文件添加到本地仓库？</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#3%E3%80%81git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4" rel="nofollow" target="_self">3、Git常用命令</a>
        </p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a
                href="#4%E3%80%81git%E5%92%8Csvn%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F" rel="nofollow"
                target="_self">4、Git和SVN有什么区别?</a></p>
        <p id="" style="margin: 0px 0px 2px 96px; padding-left: 24px;"><a href="#t11" rel="nofollow"
                target="_self">十一、B站开源视频大汇总，前端从入门到精通</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#R18LT" rel="nofollow"
                target="_self">1、web 入门（HTML5+CSS3）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#umTpf" rel="nofollow"
                target="_self">2、js（JavaScript+jQuery+Ajax）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#HIabi" rel="nofollow"
                target="_self">3、Vue 开发（Vue2+Vue3+实战项目）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#TjeW0" rel="nofollow"
                target="_self">4、React &amp;&amp;微信小程序开发&amp;&amp;uniapp</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#rbn7R" rel="nofollow"
                target="_self">5、华为鸿蒙进阶</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#BIxVr" rel="nofollow"
                target="_self">6、ssr（Nuxt+Next.js）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#WMdgv" rel="nofollow"
                target="_self">7、工程化（webpack+vite）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#t8tQu" rel="nofollow"
                target="_self">8、可视化（echarts ）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#ZnO6V" rel="nofollow"
                target="_self">9、源码（虚拟DOM和diff算法）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#UK8Wv" rel="nofollow"
                target="_self">10、移动App跨端开发（Uni-App）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#FE9co" rel="nofollow"
                target="_self">11、桌面应用开发（Electron）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#JhreY" rel="nofollow"
                target="_self">12、网络知识（网络概述+结构算法）</a></p>
        <p id="" style="margin: 0px 0px 2px 144px; padding-left: 24px;"><a href="#LATLr" rel="nofollow"
                target="_self">13、浏览器底层原理</a></p>
        <p id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%EF%BC%9F-toc"
            style="margin: 0px;"></p>
        <ul>
            <li><a href="https://blog.csdn.net/q95548854/article/details/98617043?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168894962516800182165981%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168894962516800182165981&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-98617043-null-null.142%5Ev88%5Einsert_down28v1,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98#_1325"
                    title="觉得有帮助的小伙伴右上角点赞收藏哦~会一直持续更新得呦~有好的建议私信我~">觉得有帮助的小伙伴右上角点赞收藏哦~会一直持续更新得呦~有好的建议私信我~</a></li>
        </ul>
        <hr>
        <h4 id="%E4%B8%80%E3%80%81HTML%E7%AF%87"><a name="t0"></a><span
                style="color:#0d0016;"><strong>一、</strong>HTML篇</span></h4>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%911.%20HTML5%20%E6%96%B0%E5%A2%9E%E9%82%A3%E4%BA%9B%E6%A0%87%E7%AD%BE%3F">
            <strong><span style="color:#000000;">1、HTML5 新增那些标签? </span></strong></h5>
        <blockquote>
            <p><span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">（1）布局标签（语义化标签）</span></strong></span></p>
            <ul>
                <li><span style="color:#0d0016;"><strong>&lt;header&gt;</strong> : 头部标签</span></li>
                <li><span style="color:#0d0016;"><strong>&lt;nav&gt;</strong> :&nbsp; &nbsp; &nbsp; &nbsp;导航标签</span>
                </li>
                <li><span style="color:#0d0016;"><strong>&lt;article&gt;</strong> :&nbsp; &nbsp;内容标签</span></li>
                <li><span style="color:#0d0016;"><strong>&lt;section&gt;</strong> : 定义文档某个区域</span></li>
                <li><span style="color:#0d0016;"><strong>&lt;aside&gt; </strong>:&nbsp; &nbsp; 侧边栏标签</span></li>
                <li><span style="color:#0d0016;"><strong>&lt;footer&gt;</strong> :&nbsp; &nbsp;底部标签</span></li>
            </ul>
            <p><span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">图形结合记忆法：</span></strong></span></p>
            <p><img alt="" height="339"
                    src="https://i-blog.csdnimg.cn/blog_migrate/3e084388c8904997725bca2d7ee2a11e.png" width="445"></p>
            <p><span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">（2）视频标签(video)</span></strong></span></p>
            <p><img alt="" height="270"
                    src="https://i-blog.csdnimg.cn/blog_migrate/eb7ed8061ba6ab7daad250df947bb5a4.png" width="654"></p>
            <p><span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">（3）audio(音频)</span></strong></span></p>
            <p><img alt="" height="209"
                    src="https://i-blog.csdnimg.cn/blog_migrate/f1d2fdc3d2ff01d91d21db8be526ba19.png"
                    width="652">&nbsp;&nbsp;</p>
            <p><strong>（4）新的 API</strong></p>
            <ul>
                <li>音视频：audio 和 video 元素</li>
                <li>绘图图形：canvas 元素</li>
                <li>本地存储：localStorage，sessionStorage</li>
                <li>多线程操作：Web Worker （Web Worker 是HTML5 新特性，允许我们在 js 主线程之外开辟新线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js
                    操作多线程的能力&nbsp;）</li>
            </ul>
            <p><span style="color:#1c7331;">更多HTML5新属性=&gt;W3Cschool官网：<a
                        href="https://www.w3cschool.cn/html5/html5-intro.html" rel="nofollow"
                        title="开始学习HTML5_w3cschool">开始学习HTML5_w3cschool</a></span></p>
            <p style="margin-left:0;text-align:left;"><span style="color:#0d0016;"><strong>语义化的优点如下：</strong></span></p>
            <ul>
                <li id="uff2a7fb2"><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">在没有CSS样式情况下也能够让页面呈现出清晰的结构</span></span></li>
                <li id="u44452a6b"><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">有利于SEO和搜索引擎建立良好的沟通，有助于爬虫抓取更多的有效信息，爬虫是依赖于标签来确定上下文和各个关键字的权重</span></span>
                </li>
                <li id="u79bf2f43"><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">方便团队开发和维护，语义化更具可读性，遵循W3C标准的团队都遵循这个标准，可以减少差异化</span></span>
                </li>
            </ul>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%913.%20%E5%88%97%E4%B8%BE%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%A0%E4%B8%AA%E5%9D%97%E7%BA%A7%E6%A0%87%E7%AD%BE%E5%92%8C%E8%A1%8C%E5%86%85%E6%A0%87%E7%AD%BE%EF%BC%9F">
            <strong><span style="color:#000000;">2、常见的块元素、行内元素以及行内块元素，三者有何不同？ </span></strong></h5>
        <blockquote>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">（1）块元素</span></span></p>
            <p><img alt="" height="353"
                    src="https://i-blog.csdnimg.cn/blog_migrate/f9d880150dacc4f43f2fdd849a99495e.png" width="669"></p>
            <p><span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">（2）行内元素：a，span，em(i)，strong(b)，u</span></span></p>
            <p><img alt="" height="325"
                    src="https://i-blog.csdnimg.cn/blog_migrate/6329df11329032cc2c7a8a4799d04b45.png" width="661"></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">&nbsp;（3）行内块元素</span></span></p>
            <p><img alt="" height="200"
                    src="https://i-blog.csdnimg.cn/blog_migrate/6707a20950f7172c47ccba9cd14519ee.png" width="674"></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%914.%20%E7%AE%80%E8%BF%B0%20readyonly%20%E4%B8%8E%20disabled%20%E7%9A%84%E5%8C%BA%E5%88%AB">
            <strong><span style="color:#000000;">3、</span>HTML、XML、XHTML它们之间有什么区别？</strong></h5>
        <p style="text-align:center;"><img alt=""
                src="https://i-blog.csdnimg.cn/blog_migrate/98db3627b8b9aa5cc357e121d0bd8ff2.png"></p>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%915.%20HTML5%20%E7%9A%84%E7%BD%91%E9%A1%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99%3C!DOCTYOE%20HTML%3E%3F">
            <strong><span style="color:#000000;">4、</span></strong>DOCTYPE(⽂档类型) 的作⽤</h5>
        <blockquote>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Doctype是HTML5的文档声明，通过它可以告诉浏览器，使用哪一个HTML版本标准解析文档。在浏览器发展的过程中，HTML出现过很多版本，不同的版本之间格式书写上略有差异。如果没有事先告诉浏览器，那么浏览器就不知道文档解析标准是什么？此时，大部分浏览器将开启最大兼容模式来解析网页，我们一般称为怪异模式，这不仅会降低解析效率，而且会在解析过程中产生一些难以预知的bug，所以文档声明是必须的。
            </p>
            <p></p>
            <p><span style="color:#000000;">浏览器渲染页面的两种模式（可通过document.compatMode获取）：</span></p>
            <ul>
                <li><span style="color:#000000;">CSS1Compat：标准模式（Strick
                        mode），默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</span></li>
                <li><span style="color:#000000;">BackCompat：怪异模式(混杂模式)(Quick
                        mode)，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</span></li>
            </ul>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%916.HTML5%20%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F">
            5、<strong>localStorage、sessionStorage、cookie 三者明细区别</strong>？</h5>
        <p style="text-align:center;"><img alt="" height="267"
                src="https://i-blog.csdnimg.cn/blog_migrate/17cf0c07ccca23789dd68b2eb011d59f.webp?x-image-process=image/format,png"
                width="641"></p>
        <blockquote>
            <ol>
                <li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li>
                <li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li>
                <li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>
            </ol>
            <p><strong>存储大小</strong></p>
            <ul>
                <li>cookie数据大小不能超过4k。</li>
                <li>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
            </ul>
            <p><strong>有期时间</strong></p>
            <ul>
                <li>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；</li>
                <li>sessionStorage 数据在当前浏览器窗口关闭后自动删除。</li>
                <li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
            </ul>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%917.%E7%BD%91%E7%AB%99TDK%E4%B8%89%E5%A4%A7%E6%A0%87%E7%AD%BESEO%E4%BC%98%E5%8C%96%C2%A0">
            <strong>6、网站TDK三大标签以及SEO优化&nbsp;</strong></h5>
        <blockquote>
            <p><img alt="" height="325"
                    src="https://i-blog.csdnimg.cn/blog_migrate/33d2ebe450801a209106c9eca7ebaa9d.png" width="720"></p>
            <p></p>
            <p>TDK是网站<span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">标题（title）、描述（description）、关键词（keywords）</span></strong></span>这三者的英文首字母缩写，主要用来对当前网页进行总结和概况。
            </p>
            <p>在SEO界，<strong>标题、描述、关键词</strong>通常也被称为三大标签。</p>
            <p><img alt="" height="371"
                    src="https://i-blog.csdnimg.cn/blog_migrate/9a61bf9b68319ba463b84a8b2e5a23d0.png" width="676"></p>
        </blockquote>
        <h5
            id="7%E3%80%81%E6%A0%87%E7%AD%BE%E4%B8%8Atitle%E5%B1%9E%E6%80%A7%E4%B8%8Ealt%E5%B1%9E%E6%80%A7%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
            7、img标签的title属性与alt属性的区别是什么？</h5>
        <blockquote>
            <ul>
                <li><span
                        style="color:#be191c;"><code><span style="background-color:#fef2f0;">alt</span></code></span>是给搜索引擎识别，在图像无法显示时的替代文本
                </li>
                <li><span
                        style="color:#be191c;"><code><span style="background-color:#fef2f0;">title</span></code></span>属性是关于元素的注释信息，主要是给用户解读
                </li>
                <li>在定义 img 对象时，将 alt 和 title 属性写全，可以保证在各种浏览器中都能正常使用</li>
            </ul>
            <p><strong>注意：（IE已淘汰，仅做了解即可）</strong></p>
            <p>当鼠标放到文字或是图片上时有 title 文字显示。</p>
            <p>（因为IE不标准）在 IE 浏览器中 alt 起到了 title 的作用，变成文字提示。</p>
        </blockquote>
        <h5 id="8%E3%80%81src%20%E5%92%8C%20href%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">8、src 和 href 的区别？</h5>
        <blockquote>
            <p id="u0f6b7d92">src和href都是HTML中特定元素的属性，都可以用来引入外部的资源。两者区别如下：</p>
            <ul>
                <li id="u8dc9ed8b">
                    src：全称<em>source</em>，它通常用于img、video、audio、script元素，通过src指向请求外部资源的来源地址，指向的内容会嵌入到文档中当前标签所在位置，在请求src资源时，它会将资源下载并应用到文档内，比如说：js脚本、img图片、frame等元素。当浏览器解析到该元素时，会暂停其它资源下载，直到将该资源加载、编译、执行完毕。这也是为什么将js脚本放在底部而不是头部的原因。
                </li>
                <li id="u1e6e1332">href：全称<em>hyper
                        reference</em>，意味着超链接，指向网络资源，当浏览器识别到它指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理，通常用于a、link元素。</li>
            </ul>
        </blockquote>
        <h5
            id="9%E3%80%81title%20%E4%B8%8E%20h1%20%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81b%20%E4%B8%8E%20strong%20%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81i%20%E4%B8%8E%20em%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0">
            9、title 与 h1 的区别、b 与 strong 的区别、i 与 em 的区别？&nbsp;</h5>
        <blockquote>
            <p></p>
            <p><strong>title与h1的区别</strong></p>
            <ul>
                <li>从网站角度看，title 更重于网站信息。title可以直接告诉搜索引擎和用户这个网站是关于什么主题和内容的。</li>
                <li>从文章角度看，h1则是用于概括文章主题。</li>
                <li>一个网站可以有多个title,最好一个单页用一个title，以便突出网站页面主体信息，从seo看，title权重比h1高，适用性比h1广。</li>
                <li>标记了h1的文字页面给予的权重会比页面内其他权重高很多。一个好的网站是h1和title并存，既突出h1文章主题，又突出网站主题和关键字。达到双重优化网站的效果。</li>
            </ul>
            <p><strong>b与strong 的区别</strong></p>
            <ul>
                <li>b 是只是对文本的简单加粗， strong 是一个语义化标签，对相关文本具有强调作用</li>
                <li>b 标签只是侧重于字体加粗， strong标签加强字体的语气都是通过粗体来实现的，相比之下，搜索引擎更喜欢侧重于strong标签</li>
                <li>strong标签更注重于内容上的应用，在html中，对关键词的标明，然而还有一些网站上，也有使用strong标签登对小标题进行强调，但是在页面中，如果出现过多的strong标签，可能会对排名不利。
                </li>
            </ul>
            <p><strong>i 与 em 的区别</strong></p>
            <ul>
                <li>&nbsp;i(italic)是实体标签，用来使字符倾斜，em(emphasis)是逻辑标签，作用是强调文本内容</li>
                <li>i标签只是斜体的样式，没有实际含义，常用来表达无强调或着重意味的斜体，比如生物学名、术语、外来语；</li>
                <li>em表示标签内字符重要，用以强调，其默认格式是斜体，但是可以通过CSS添加样式。</li>
                <li>建议：为了符合CSS3的规范，i 标签应尽量少用而应改用 em</li>
            </ul>
            <p></p>
        </blockquote>
        <h5 id="8%E3%80%81iframe%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%20%EF%BC%9F">10、<a
                href="https://so.csdn.net/so/search?q=iframe&amp;spm=1001.2101.3001.7020"
                title="iframe">iframe</a>的优点和缺点 ？</h5>
        <p><span style="color:#be191c;"><strong><span
                        style="background-color:#fef2f0;">iframe的缺点：</span></strong></span></p>
        <ol>
            <li>页面样式调试麻烦，出现多个滚动条；</li>
            <li>浏览器的后退按钮失效；</li>
            <li>过多会增加服务器的HTTP请求；</li>
            <li>小型的移动设备无法完全显示框架；</li>
            <li>产生多个页面，不易管理；</li>
            <li>不容易打印；</li>
            <li>代码复杂，无法被一些搜索引擎解读。</li>
            <li>搜索引擎的检索程序无法解读这种页面，不利于SEO;</li>
        </ol>
        <p><span style="color:#be191c;"><strong><span
                        style="background-color:#fef2f0;">iframe的优点：</span></strong></span></p>
        <ol>
            <li>iframe能够原封不动的把嵌入的网页展现出来。</li>
            <li>如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。</li>
            <li>网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。</li>
            <li>如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。</li>
            <li>重载页面时不需要重载整个页面，只需要重载页面中的一个框架页(减少了数据的传输，增加了网页下载速度)</li>
        </ol>
        <p><strong>总而言之：</strong></p>
        <ul>
            <li>运维性网站或继承性开发的网站，可以使用iframe;</li>
            <li>销售内，官网、展示性网站等建议不使用iframe;</li>
            <li>标准的网页设计是不使用iframe的。</li>
        </ul>
        <h4 id="%E4%BA%8C%E3%80%81CSS%E7%AF%87"><a name="t1"></a><span
                style="color:#0d0016;"><strong>二、</strong>CSS篇</span></h4>
        <p style="text-align:center;"><span style="color:#0d0016;"><img alt="" height="270"
                    src="https://i-blog.csdnimg.cn/blog_migrate/653f107d05836cd63ec7128038bc196a.png"
                    width="769"></span></p>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%911.%E7%AE%80%E6%98%8E%E8%AF%B4%E4%B8%80%E4%B8%8B%20CSS%20link%20%E4%B8%8E%20%40import%20%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95%EF%BC%9F">
            1、说一下 link 与 @import 的区别和用法？</h5>
        <blockquote>
            <p>页面导入外部css文件的方法通常有两种，一种在网页中直接link标签加入，另一种在页面中@import引入css文件。两种引入形式如下：<br> link引入形式：</p>
            <pre data-index="0" class="set-code-show"
                name="code"><code class="language-javascript hljs">&lt;link href=<span class="hljs-string">"styles.css"</span> type=<span class="hljs-string">"text/css"</span> /&gt;</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p>@import引用形式：</p>
            <pre data-index="1" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;style type=<span class="hljs-string">"text/css"</span>&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    @<span class="hljs-keyword">import</span> <span class="hljs-title function_">url</span>(<span class="hljs-string">"styles.css"</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/style&gt;</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p><strong>1、适用范围不同</strong><br> @import可以在网页页面中使用，也可以在css文件中使用，用来将多个css文件引入到一个css文件中；而link只能将css文件引入到网页页面中。
            </p>
            <p><strong>2、功能范围不同</strong><br>
                link属于XHTML标签，而@import是CSS提供的一种方式，link标签除了可以加载CSS外，还可以定义rel连接属性，定义RSS等，@import就只能加载CSS。<br><strong>3、加载顺序不同</strong><br>
                页面被加载的时候，link引用的CSS会同时被加载，而@import引用的CSS会等到页面全部被下载完再被加载。所以有时候浏览@import加载CSS的页面时开始会没有样式（就是闪烁）<br><strong>4、兼容性</strong><br>
                由于@import是css2.1提出的，所以老的浏览器不支持，@import只有在IE5以上的才能识别，而link标签无此问题。<br><strong>5、控制样式时的差别</strong><br>
                使用link方式可以让用户切换CSS样式.现代浏览器如Firefox,Opera,Safari都支持rel=”alternate
                stylesheet”属性(即可在浏览器上选择不同的风格),当然你还可以使用<span class="words-blog hl-git-1"
                    data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.10283&quot;,&quot;extra&quot;:&quot;{\&quot;words\&quot;:\&quot;Javascript\&quot;}&quot;}"
                    data-tit="Javascript"
                    data-pretit="javascript">Javascript</span>使得IE也支持用户更换样式。<br><strong>6、使用DOM控制样式时的差别</strong><br>
                当使用JavaScript控制DOM去改变样式的时候，只能使用link标签，因为@import不是DOM可以控制的。</p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%912.rgba%E5%92%8Copacity%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F">
            2、rgba和opacity的透明效果有什么不同？</h5>
        <blockquote>
            <ul>
                <li><strong>opacity</strong></li>
            </ul>
            <p>opacity是一个属性。opacity属性的值，可以被其子元素继承，给父级div设置opacity属性，那么所有子元素都会继承这个属性，并且，该元素及其继承该属性的所有子元素的所有内容透明度都会改变。</p>
            <ul>
                <li><strong>rgba（0，0，0，0.5）</strong></li>
            </ul>
            <p>rgba是一个属性值。rgba设置的元素，只对该元素的背景色有改变，并且，该元素的后代不会继承该属性。<br> 补冲：rgba只是一个属性值，在background
                里用改变背景色，在color里是改字体颜色，shadow里是改阴影色，不止是能够改元素的背景色，要看具体是在哪个属性上用</p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%913.%20display%3Anone%E5%92%8Cvisibility%3Ahidden%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">
            3、display:none与visibility:hidden的区别？</h5>
        <blockquote>
            <p>这两个属性都是让元素隐藏，不可见。两者区别如下：</p>
            <p>（1）在渲染树中</p>
            <ul>
                <li><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">display:none会让元素完全从渲染树中消失，渲染时不会占据任何空间；</span></span></li>
                <li><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">visibility:hidden不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</span></span>
                </li>
            </ul>
            <p>（2）是否是继承属性</p>
            <ul>
                <li>display:none是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li>
                <li>visibility:hidden是继承属性，子孙节点消失是由于继承了hidden，通过设置visibility:visible可以让子孙节点显示；</li>
            </ul>
            <p>（3）修改常规文档流中元素的 display 通常会造成文档的重排，但是修改visibility属性只会造成本元素的重绘；<br>
                （4）如果使用读屏器，设置为display:none的内容不会被读取，设置为visibility:hidden的内容会被读取。</p>
            <p>（5）display：none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。<br> （6）visibility：hidden
                隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
            <p><img alt="" height="172"
                    src="https://i-blog.csdnimg.cn/blog_migrate/b00cb599cbc0ea3bcf6260323ff61e76.png" width="676"></p>
            <p><img alt="" height="166"
                    src="https://i-blog.csdnimg.cn/blog_migrate/285fff5bd557c912b5a5cbac885d4771.png" width="647"></p>
            <p><img alt="" height="244"
                    src="https://i-blog.csdnimg.cn/blog_migrate/c05ff7576f9b558e9bb8f8db69befc85.png" width="666"></p>
        </blockquote>
        <h5
            id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%914.%E5%87%A0%E7%A7%8D%E5%AE%9A%E4%BD%8D%E5%B8%83%E5%B1%80%20position%E7%9A%84%E5%80%BC%EF%BC%8C%20relative%E5%92%8Cabsolute%E5%88%86%E5%88%AB%E6%98%AF%E7%9B%B8%E5%AF%B9%E4%BA%8E%E8%B0%81%E8%BF%9B%E8%A1%8C%E5%AE%9A%E4%BD%8D%E7%9A%84%EF%BC%9F">
            4、定位布局 position中的relative、absolute、fixed、sticky它们之间的区别？</h5>
        <p><img alt="" height="277" src="https://i-blog.csdnimg.cn/blog_migrate/e3c568b4fddb2844baee3e154238947d.png"
                width="723"></p>
        <blockquote>
            <p><strong>（1）relative:相对定位，相对于自己本身在正常文档流中的位置进行定位。</strong></p>
            <p><img alt="" height="127"
                    src="https://i-blog.csdnimg.cn/blog_migrate/99ab01d2706ca7bef599d2158ab954e8.png"
                    width="677"><br><strong>（2）absolute:生成绝对定位，相对于最近一级定位不为static的父元素进行定位。</strong></p>
            <p><img alt="" height="138"
                    src="https://i-blog.csdnimg.cn/blog_migrate/c50fff92e4d793822080fbe8dba25cf8.png" width="672"></p>
            <p><strong>（3）fixed: 生成绝对定位，相对于浏览器窗口或者frame进行定位。（老版本IE不支持）</strong></p>
            <p><img alt="" height="236"
                    src="https://i-blog.csdnimg.cn/blog_migrate/3eb84b90fcbb25e8a9d505659a3ef826.png"
                    width="685"><br><strong>（4）static:默认值，没有定位，元素出现在正常的文档流中。（很少用）<br>
                    （5）sticky:生成粘性定位的元素，容器的位置根据正常文档流计算得出。（很少用）</strong></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%91%C2%A05.%20%E7%94%A8CSS3%E7%94%BB%E4%B8%80%E6%9D%A10.5px%E7%9A%84%E7%9B%B4%E7%BA%BF%EF%BC%9F">
            5、如何用CSS3画一条0.5px的直线？</h5>
        <pre data-index="2" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">height</span>: 1px;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">transform</span>: <span class="hljs-title function_">scale</span>(<span class="hljs-number">0.5</span>);</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <h5
            id="%C2%A0%C2%A0%E2%80%8B%E7%BC%96%E8%BE%91%C2%A06.%20%E7%94%A8CSS3%E7%94%BB%E4%B8%80%E4%B8%AA%E4%B8%89%E8%A7%92%E5%BD%A2%EF%BC%9F">
            6、如何用CSS3画一个三角形？</h5>
        <pre data-index="3" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;style&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">.<span class="hljs-property">up</span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">width</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">height</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">border</span>: 100px solid transparent;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    border-<span class="hljs-attr">top</span>: 100px solid red;<span class="hljs-comment">/*红色*/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">.<span class="hljs-property">down</span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">width</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">height</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">border</span>: 100px solid transparent;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    border-<span class="hljs-attr">bottom</span>: 100px solid blue;<span class="hljs-comment">/*蓝色*/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">.<span class="hljs-property">left</span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">width</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">height</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">border</span>: 100px solid transparent;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    border-<span class="hljs-attr">left</span>: 100px solid pink;<span class="hljs-comment">/*黑色*/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">.<span class="hljs-property">right</span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">width</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">height</span>:<span class="hljs-number">0</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">border</span>: 100px solid transparent;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    border-<span class="hljs-attr">right</span>: 100px solid pink;<span class="hljs-comment">/*黄色*/</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/style&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="29"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"up"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="30"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"down"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="31"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="32"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="33"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p><span style="color:#fe2c24;"><strong>实现效果：</strong></span></p>
        <p>&nbsp;<img alt="" height="88"
                src="https://i-blog.csdnimg.cn/blog_migrate/4a7168a74462c2e1a961b11ee9998227.png" width="172"><img
                alt="" height="110" src="https://i-blog.csdnimg.cn/blog_migrate/164e142df8e0a6034f7aaef2ea98272c.png"
                width="196"><img alt="" height="185"
                src="https://i-blog.csdnimg.cn/blog_migrate/f7a82e0ba81918ed2cbe65d599b48f79.png" width="123"><img
                alt="" height="182" src="https://i-blog.csdnimg.cn/blog_migrate/1c77cf35ca8abc0df39571e9b9a52538.png"
                width="125"></p>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%917.CSS3%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B">7、<strong>CSS3盒子模型：</strong><span
                style="color:#000008;"><strong>标准盒模型、怪异盒模型</strong></span></h5>
        <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">盒子模型分为两种:
                    </span></strong></span></p>
        <ul>
            <li><span style="color:#000008;">第一种是 W3C 标准的盒子模型（标准盒模型） </span></li>
            <li><span style="color:#000008;">第二种 IE 标准的盒子模型（怪异盒模型） </span></li>
        </ul>
        <p><span style="color:#000008;"><strong>标准盒模型与怪异盒模型的表现效果的区别之处： </strong></span></p>
        <p><span style="color:#000008;">1、标准盒模型中 width 指的是内容区域 content 的宽度 </span></p>
        <p><span style="color:#000008;">height 指的是内容区域 content 的高度 </span></p>
        <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">标准盒模型下盒子的大小 = content + border +
                        padding + margin</span></strong></span></p>
        <p style="text-align:center;"><img alt="" height="445"
                src="https://i-blog.csdnimg.cn/blog_migrate/df364113825ef32a634fb6fe3dc57d76.png" width="730"></p>
        <p></p>
        <p><span style="color:#000008;">2、怪异盒模型中的 width 指的是内容、边框、内边距总的宽度（content + border + padding）；height
                指的是内容、边框、内边距总的高度</span></p>
        <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">怪异盒模型下盒子的大小=width（content + border +
                    padding） + margin</span></span></p>
        <p style="text-align:center;"><img alt="" height="413"
                src="https://i-blog.csdnimg.cn/blog_migrate/f3e8227cbb0ebfe001563e0216df364b.png" width="707"></p>
        <p><span style="color:#000008;">除此之外，我们还可以通过属性 box-sizing 来设置盒子模型的解析模式 </span></p>
        <p><span style="color:#000008;">可以为 box-sizing 赋两个值：</span></p>
        <p><span style="color:#000008;">1、</span><span style="color:#be191c;"><strong><span
                        style="background-color:#fef2f0;">box-sizing: content-box</span></strong></span><span
                style="color:#000008;">：默认值，border 和 padding 不算到 width 范围内，可以理解为是 W3c
                的标准模型(default)。<strong>总宽=width+padding+border+margin </strong></span></p>
        <p><span style="color:#000008;">2、</span><span style="color:#be191c;"><strong><span
                        style="background-color:#fef2f0;">box-sizing: border-box</span></strong></span><span
                style="color:#000008;">：border 和 padding 划归到 width 范围内，可以理解为是 IE
                的怪异盒模型，<strong>总宽=width+margin</strong></span></p>
        <ul>
            <li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">相邻块元素垂直外边距的合并
                        </span></strong></span></li>
        </ul>
        <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="267"
                src="https://i-blog.csdnimg.cn/blog_migrate/7787f921ebd42f643c5d30c884bc7b86.png" width="710"></p>
        <ul>
            <li id="2.%E5%B5%8C%E5%A5%97%E5%9D%97%E5%85%83%E7%B4%A0%E5%9E%82%E7%9B%B4%E5%A4%96%E8%BE%B9%E8%B7%9D%E7%9A%84%E5%A1%8C%E9%99%B7"
                style="text-align:justify;"><span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">嵌套块元素垂直外边距的塌陷</span></strong></span></li>
        </ul>
        <p><img alt="" height="218" src="https://i-blog.csdnimg.cn/blog_migrate/0dcc15e63b2372bace293e0a950c8228.png"
                width="679"></p>
        <h5 id="8.%E6%B5%AE%E5%8A%A8%EF%BC%88float)"><strong>8、浮动（float)以及清除浮动的方法</strong></h5>
        <p id="1.%E8%84%B1%E6%A0%87" style="text-align:justify;"><span style="color:#be191c;"><span
                    style="background-color:#fef2f0;">(1) 脱标</span></span></p>
        <p><img alt="" height="100" src="https://i-blog.csdnimg.cn/blog_migrate/d56248257328d9e9cb3ef1f971d7b45c.png"
                width="740"></p>
        <p id="2.%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8" style="text-align:justify;"><span style="color:#be191c;"><span
                    style="background-color:#fef2f0;">(2) 清除浮动</span></span></p>
        <p><img alt="" height="115" src="https://i-blog.csdnimg.cn/blog_migrate/7f942525c91f3e8d4739df6959a85779.png"
                width="751"></p>
        <p><img alt="" height="305" src="https://i-blog.csdnimg.cn/blog_migrate/ebb5374bc549e90b2399e53a3b93cfab.png"
                width="746"></p>
        <p id="3.%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%9A"><span
                style="color:#be191c;"><span style="background-color:#fef2f0;">(3) 清除浮动的方法</span></span></p>
        <ul>
            <li
                id="1%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%20%E2%80%94%E2%80%94%20%E9%A2%9D%E5%A4%96%E6%A0%87%E7%AD%BE%E6%B3%95%E2%80%8B%E7%BC%96%E8%BE%91">
                <span style="color:#be191c;"><span style="background-color:#fef2f0;">清除浮动 —— </span><strong><span
                            style="background-color:#fef2f0;">额外标签法</span></strong></span><img alt="" height="219"
                    src="https://i-blog.csdnimg.cn/blog_migrate/22d2c1a0b63cd39e23212c76a30c7c7b.png" width="767"></li>
            <li
                id="2%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%20%E2%80%94%E2%80%94%20%E7%88%B6%E7%BA%A7%E6%B7%BB%E5%8A%A0%20overflow">
                <span style="color:#be191c;"><span style="background-color:#fef2f0;">清除浮动 —— 父级添加 overflow
                    </span></span></li>
        </ul>
        <p><img alt="" height="187" src="https://i-blog.csdnimg.cn/blog_migrate/8fce016640de23a8fcdbce5ff9235094.png"
                width="805"></p>
        <ul>
            <li
                id="3%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%20%E2%80%94%E2%80%94%20%3Aafter%20%E4%BC%AA%E5%85%83%E7%B4%A0%E6%B3%95">
                <span style="color:#be191c;"><span style="background-color:#fef2f0;">清除浮动 —— :after 伪元素法</span></span>
            </li>
        </ul>
        <p><img alt="" height="279" src="https://i-blog.csdnimg.cn/blog_migrate/f3ca9abfdfb7c7cb4eebc5abb59d05b9.png"
                width="744"></p>
        <ul>
            <li
                id="4%E3%80%81%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%20%E2%80%94%E2%80%94%20%E5%8F%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8">
                <span style="color:#be191c;"><span style="background-color:#fef2f0;">清除浮动 —— 双伪元素清除浮动</span></span></li>
        </ul>
        <p><img alt="" height="330" src="https://i-blog.csdnimg.cn/blog_migrate/19d0796d005bde4b76c832172e292ec3.png"
                width="511"></p>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%919%E3%80%81Flex%E5%B8%83%E5%B1%80">9、Flex布局</h5>
        <blockquote>
            <p style="margin-left:.0001pt;text-align:justify;"><strong>1、主轴对齐方式</strong></p>
            <p><span style="color:#595959;">使用</span><span style="color:#c00000;">justify-content</span><span
                    style="color:#595959;">调节元素在</span><span style="color:#c00000;">主轴的对齐方式</span></p>
            <p><img alt="" height="190"
                    src="https://i-blog.csdnimg.cn/blog_migrate/c6904a89eb615787bef79d983f211d6b.png" width="683"></p>
            <p style="text-align:justify;"><strong>2、侧轴对齐方式 </strong></p>
            <p style="margin-left:.0001pt;text-align:left;"><span style="color:#595959;">使用</span><span
                    style="color:#c00000;">align-items</span><span style="color:#595959;">调节元素在</span><span
                    style="color:#c00000;">侧轴的对齐方式</span></p>
            <p style="margin-left:.0001pt;text-align:left;"><img alt="" height="272"
                    src="https://i-blog.csdnimg.cn/blog_migrate/338537792d5ca5b4d9bab103b4efa136.png" width="744"></p>
            <p><strong>3、换轴</strong></p>
            <p><span style="color:#595959;">使用</span><span style="color:#c00000;">flex-direction</span><span
                    style="color:#595959;">改变元素排列方向</span></p>
            <p><img alt="" height="258"
                    src="https://i-blog.csdnimg.cn/blog_migrate/3cdb8a1a4f234e9f95a4e92fcfafdb92.png" width="661"></p>
            <p><strong>4、弹性盒子换行</strong></p>
            <p><span style="color:#595959;">目标：使用</span><span style="color:#c00000;">flex-wrap</span><span
                    style="color:#595959;">实现弹性盒子</span><span style="color:#c00000;">多行</span><span
                    style="color:#595959;">排列效果</span></p>
            <p><img alt="" height="171"
                    src="https://i-blog.csdnimg.cn/blog_migrate/ac8ccbe51fb70867d3a0bddd4be806ab.png" width="680"></p>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%9110%E3%80%81CSS%E5%B9%B3%E9%9D%A2%E8%BD%AC%E6%8D%A2">
            10、CSS3中“transform”属性~平面转换</h5>
        <blockquote>
            <p id="%EF%BC%881%EF%BC%89%E4%BD%8D%E7%A7%BB%EF%BC%9Atransform%3A%20translate(%E6%B0%B4%E5%B9%B3%E7%A7%BB%E5%8A%A8%E8%B7%9D%E7%A6%BB%2C%20%E5%9E%82%E7%9B%B4%E7%A7%BB%E5%8A%A8%E8%B7%9D%E7%A6%BB)"
                style="text-align:justify;"><span style="color:#000000;"><strong>（1）位移：</strong>transform:
                    translate(水平移动距离, 垂直移动距离)</span></p>
            <p><img alt="" height="270"
                    src="https://i-blog.csdnimg.cn/blog_migrate/e3a752cf79cb87e3a66ccb408364e852.png" width="701"></p>
            <p>&nbsp;<strong>（2）旋转</strong></p>
            <p style="margin-left:.0001pt;"><span style="color:#000000;">transform: rotate(角度);</span>&nbsp;<span
                    style="color:#000000;">注意：角度单位是</span><span style="color:#c00000;">deg </span></p>
            <p style="margin-left:.0001pt;"><span style="color:#000000;">取值为</span><span
                    style="color:#c00000;">正</span><span style="color:#000000;">, 则</span><span
                    style="color:#c00000;">顺</span><span style="color:#000000;">时针旋转 </span><span
                    style="color:#000000;">Ø </span><span style="color:#000000;">取值为</span><span
                    style="color:#c00000;">负</span><span style="color:#000000;">, 则</span><span
                    style="color:#c00000;">逆</span><span style="color:#000000;">时针旋转</span></p>
            <p style="margin-left:.0001pt;text-align:left;"><strong>（3）缩放</strong></p>
            <ul>
                <li style="margin-left:.0001pt;text-align:left;">transform: scale(x轴缩放倍数, y轴缩放倍数);</li>
                <li style="margin-left:.0001pt;text-align:left;">transform: scale(缩放倍数);</li>
                <li style="margin-left:.0001pt;text-align:left;">scale值大于1表示放大, scale值小于1表示缩小</li>
            </ul>
            <p><strong>（4）</strong><span style="color:#0d0016;">transition的基本用法</span></p>
            <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">transition：[属性名] [持续时间]
                            [速度曲线] [延迟时间]</span></strong></span></p>
            <p><u><span style="color:#0d0016;">我们可以很方便的用这个过渡来给某一个属性加上好看的动效。</span></u></p>
            <p><u><span style="color:#0d0016;">例如，高度属性的值改变时，延迟 0.5 秒后以 ease 曲线进行过渡，持续2秒：</span></u></p>
            <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">transition:height 2s ease
                            0.5s</span></strong></span><br><span style="color:#0d0016;">或者一个属性不够，想要监听所有属性。</span></p>
            <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">transition: all 2s ease
                            .5s</span></strong></span></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9111%E3%80%81CSS%E4%B8%AD%E7%9A%84%E2%80%9C%E5%AD%90%E7%BB%9D%E7%88%B6%E7%9B%B8%E2%80%9D">
            11、CSS3中 “子绝父相” 定位布局</h5>
        <blockquote>
            <p>弄清楚这个口诀，就明白了绝对定位和相对定位的使用场景。<br> 这个“子绝父相”太重要了，是我们学习定位的口诀，是定位中最常用的一种方式这句话的意思是：<span
                    style="color:#be191c;"><span style="background-color:#fef2f0;">子级是绝对定位的话，父级要用相对定位。</span></span></p>
            <ul>
                <li>① 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。</li>
                <li>② 父盒子需要加定位限制子盒子在父盒子内显示。</li>
                <li>③ 父盒子布局时，需要占有位置，因此父亲只能是相对定位。</li>
            </ul>
            <p>这就是子绝父相的由来，所以<span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">相对定位经常用来作为绝对定位的父级。</span></span></p>
            <p>总结： <span style="color:#be191c;"><span style="background-color:#fef2f0;">因为父级需要占有位置，因此是相对定位，
                        子盒子不需要占有位置，则是绝对定位</span></span><br> 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，<span
                    style="color:#be191c;"><span style="background-color:#fef2f0;">子绝父绝</span></span>也会遇到。</p>
            <p style="text-align:center;"><img alt=""
                    src="https://i-blog.csdnimg.cn/blog_migrate/f9a445cc593e280616eb25e5ce7c76cb.png"></p>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%9112%E3%80%81CSS3%E4%B8%AD%E7%9B%92%E5%AD%90%E5%B1%85%E4%B8%AD">
            12、盒子居中的几种方法：“子绝父相”、“Flex布局”、“transform”</h5>
        <blockquote>
            <p style="text-align:justify;"><strong><span style="background-color:#fef2f0;"><span
                            style="color:#be191c;">（1）利用定位（子绝父相）、margin-left、margin-top实现</span></span></strong></p>
            <p style="text-align:justify;"><img alt="" height="412"
                    src="https://i-blog.csdnimg.cn/blog_migrate/ef10bce14c1733b1273aa3b7fb1bb855.png" width="724"></p>
            <p style="text-align:justify;"><span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">（2）</span><strong><span
                            style="background-color:#fef2f0;">利用定位（子绝父相）、transform属性实现</span></strong></span></p>
            <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="430"
                    src="https://i-blog.csdnimg.cn/blog_migrate/e0213346eba2d663ec0ab5d638c71897.png" width="685"></p>
            <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">（3）</span><strong><span
                            style="background-color:#fef2f0;">利用flex布局实现盒子居中</span></strong></span></p>
            <p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="400"
                    src="https://i-blog.csdnimg.cn/blog_migrate/8f6297bea74ba86be3f63b7a73128627.png" width="737"></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9113%E3%80%81CSS3%E4%B8%AD%E5%AE%9A%E4%BD%8D%E5%8F%A0%E6%94%BE%E6%AC%A1%E5%BA%8F%20z-index">
            13、CSS3中有哪些新特性？</h5>
        <blockquote>
            <ul>
                <li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li>
                <li>圆角 （border-radius:8px）</li>
                <li>多列布局 （multi-column layout）</li>
                <li>阴影和反射 （Shadoweflect）</li>
                <li>文字特效 （text-shadow）</li>
                <li>文字渲染 （Text-decoration）</li>
                <li>线性渐变 （gradient）</li>
                <li>旋转 （transform）</li>
                <li>增加了旋转,缩放,定位,倾斜,动画,多背景</li>
            </ul>
        </blockquote>
        <h5 id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%9114%E3%80%81CSS3%E4%B8%AD%E9%80%89%E6%8B%A9%E5%99%A8%E6%9D%83%E9%87%8D">
            14、CSS3选择器及其优先级</h5>
        <blockquote>
            <p><img alt="" height="214"
                    src="https://i-blog.csdnimg.cn/blog_migrate/7b6c08b7aabe8d56c80125a1a78d4c9d.png" width="645"></p>
            <p><strong>对于选择器的优先级：</strong></p>
            <ul>
                <li>标签选择器、伪元素选择器：1</li>
                <li>类选择器、伪类选择器、属性选择器：10</li>
                <li>id 选择器：100</li>
                <li>内联样式：1000</li>
            </ul>
            <p><strong>注意事项：</strong></p>
            <ul>
                <li>!important声明的样式的优先级最高；</li>
                <li>如果优先级相同，则最后出现的样式生效；</li>
                <li>继承得到的样式的优先级最低；</li>
                <li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
                <li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
            </ul>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%9115%E3%80%81CSS3%E4%B8%AD%E8%BF%87%E6%B8%A1">15、CSS3中
            “<strong>transition</strong>”&nbsp;<strong>过渡属性 </strong></h5>
        <blockquote>
            <p><img alt="" height="295"
                    src="https://i-blog.csdnimg.cn/blog_migrate/046b4b975ee9b357ad7d6b244848b130.png" width="684"></p>
            <p><img alt="" height="265"
                    src="https://i-blog.csdnimg.cn/blog_migrate/d15d0a11e06b490625d5f4e97203af9a.png" width="682"></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9116%E3%80%81CSS3%E4%B8%AD%E7%BB%93%E6%9E%84%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8">
            16、结构伪类选择器&amp;伪元素选择器</h5>
        <blockquote>
            <p>1、结构<a
                    href="https://so.csdn.net/so/search?q=%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8&amp;spm=1001.2101.3001.7020"
                    title="伪类选择器">伪类选择器</a>：可方便的选取一个或多个特定的元素</p>
            <ul>
                <li>:first-child 选取属于其父元素的首个子元素</li>
                <li>:last-child 选取属于其父元素的最后一个子元素</li>
                <li>:nth-child(n) 选择第n个子元素</li>
            </ul>
            <p>　　　 &nbsp;&nbsp; n=even / 2n ：选取偶数孩子 &nbsp;</p>
            <p>　　　　n=odd / 2n+1 ：选取奇数孩子</p>
            <p></p>
            <p>2、<a href="https://so.csdn.net/so/search?q=%E4%BC%AA%E5%85%83%E7%B4%A0&amp;spm=1001.2101.3001.7020"
                    title="伪元素">伪元素</a>选择器：</p>
            <ul>
                <li>::first-letter / line: 文本第一个单词 / 第一行</li>
                <li>::selection: 改变选中文本的样式</li>
                <li>::before &amp; ::after</li>
            </ul>
            <p>这两兄弟特性一样：1.必须要带content属性（可以为空）</p>
            <p>　　　　　　　　　2.属于行内盒子</p>
            <p></p>
            <p>3、属性<a href="https://so.csdn.net/so/search?q=%E9%80%89%E6%8B%A9%E5%99%A8&amp;spm=1001.2101.3001.7020"
                    title="选择器">选择器</a>：</p>
            <ul>
                <li>div[class=xx]: 选择类名为xx的div</li>
                <li>div[class^=xx]: 选择以类名为xx开头的div</li>
                <li>div[class$=xx]: 选择类名是以xx结束的div</li>
                <li>div[class*=xx]: 选择类名带有xx的div</li>
            </ul>
            <p>（1）结构<span style="color:#be191c;"><span style="background-color:#fbd4d0;">伪类选择器</span></span></p>
            <p><img alt="" height="351"
                    src="https://i-blog.csdnimg.cn/blog_migrate/bb352542a98d59b2ad2d480c07d27f95.png" width="734"></p>
            <p>&nbsp;（2）<span style="color:#be191c;"><span style="background-color:#fbd4d0;">伪元素选择器</span></span></p>
            <p><img alt="" height="385"
                    src="https://i-blog.csdnimg.cn/blog_migrate/4f3e4490b049ed43e2886bc40f7ca89c.png" width="688"></p>
        </blockquote>
        <h5
            id="17%E3%80%81display%E7%9A%84block%E3%80%81inline%E5%92%8Cinline-block%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">
            17、display的block、inline和inline-block的区别？</h5>
        <p>（1）block： 会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
        <p>（2）inline： 元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
        <p>（3）inline-block： 将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
        <p>对于<a href="https://so.csdn.net/so/search?q=%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0&amp;spm=1001.2101.3001.7020"
                target="_blank" class="hl hl-1"
                data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;行内元素\&quot;}&quot;}"
                data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://so.csdn.net/so/search?q=%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;searchword\&quot;:\&quot;行内元素\&quot;}&quot;}"
                data-tit="行内元素" data-pretit="行内元素">行内元素</a>和块级元素，其特点如下：</p>
        <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">行内元素</span></span></p>
        <ul>
            <li>设置宽高无效；</li>
            <li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
            <li>不会自动换行；</li>
        </ul>
        <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">块级元素</span></span></p>
        <ul>
            <li>可以设置宽高；</li>
            <li>设置margin和padding都有效；</li>
            <li>可以自动换行；</li>
            <li>多个块状，默认排列从上到下。</li>
        </ul>
        <h5 id="18%E3%80%81%E5%AE%9A%E4%BD%8D%E5%A0%86%E5%8F%A0%E9%A1%BA%E5%BA%8Fz-index">18、定位堆叠顺序<code>z-index</code>
        </h5>
        <p>在使用定位布局时，可能会出现盒子重叠的情况。此时，可以使用 z-index 来控制盒子的前后次序 (z轴)</p>
        <blockquote>
            <p>语法： 选择器 { z-index: 1; }<br> 数值可以是正整数、负整数或 0, 默认是 auto，数值越大，盒子越靠上</p>
        </blockquote>
        <ul>
            <li>
                <p>如果属性值相同，则按照书写顺序，后来居上</p>
            </li>
            <li>
                <p>数字后面不能加单位</p>
            </li>
            <li>
                <p><code>只有定位的盒子才有 z-index 属性</code></p>
            </li>
        </ul>
        <h4 id="%E4%B8%89%E3%80%81HTML%26CSS%E6%B7%B7%E5%90%88%E7%AF%87"><a name="t2"></a><span
                style="color:#0d0016;">三、HTML&amp;&amp;CSS混合篇</span></h4>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%20Localstorage%E3%80%81sessionStorage%E3%80%81cookie%20%E7%9A%84%E5%8C%BA%E5%88%AB">
            <strong>1、</strong><span style="color:#000008;">Localstorage、sessionStorage、cookie 的区别</span></h5>
        <blockquote>
            <p><span style="color:#000008;"><strong>共同点：</strong></span><span style="color:#000008;">都是保存在浏览器端、且同源的
                </span></p>
            <p><span style="color:#000008;">三者区别： </span></p>
            <p><span style="color:#000008;">1、cookie 数据始终在同源的 http 请求中携带（即使不需要），即 cookie 在浏览器和服务器 </span></p>
            <p><span style="color:#000008;">间来回传递，而 sessionStorage 和 localStorage 不会自动把数据发送给服务器，仅在本地保存。 cookie
                    数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下 </span></p>
            <p><span style="color:#000008;">2、存储大小限制也不同，cookie 数据不能超过 4K，同时因为每次 http 请求都会携带 cookie、 所以 cookie
                    只适合保存很小的数据，如会话标识。sessionStorage 和 localStorage 虽然也有存 储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。</span></p>
            <p><span style="color:#000008;">3、数据有效期不同</span></p>
            <p><span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">sessionStorage：仅在当前浏览器窗口关闭之前有效；</span></strong></span></p>
            <p><span style="color:#be191c;"><strong><span
                            style="background-color:#fef2f0;">localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；</span></strong></span>
            </p>
            <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">cookie：只在设置的 cookie
                            过期时间之前有效，即使窗口关闭或浏览器关闭 </span></strong></span></p>
            <p><span style="color:#000008;">4、作用域不同</span></p>
            <p><span style="color:#000008;">sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；</span></p>
            <p><span style="color:#000008;">localstorage 在所有同源窗口中都是共享的；</span></p>
            <p><span style="color:#000008;">cookie 也是在所有同源窗口中都是共享的 </span></p>
            <p><span style="color:#000008;">5、web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。</span></p>
            <p><span style="color:#000008;">6、web Storage 的 api 接口使用更方便。</span></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%912%E3%80%81%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E9%A3%9E%E7%BF%BC%EF%BC%88%E5%9C%A3%E6%9D%AF%EF%BC%89%E5%B8%83%E5%B1%80%EF%BC%9F%C2%A0">
            <strong>2、</strong><span style="color:#000008;">如何实现双飞翼（圣杯）布局？</span>&nbsp;</h5>
        <p><img alt="" height="324" src="https://i-blog.csdnimg.cn/blog_migrate/b125b1b9cb2967b28965bbc72357d37a.png"
                width="850"></p>
        <blockquote>
            <p>&nbsp;<span style="color:#000008;">1、利用定位实现两侧固定中间自适应 </span></p>
            <p><span style="color:#000008;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;父盒子设置左右 padding 值 </span>
            </p>
            <p><span style="color:#000008;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;给左右盒子的 width 设置父盒子的 padding
                    值,然后分别定位到 padding 处. </span></p>
            <p><span style="color:#000008;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间盒子自适应</span></p>
            <p><span style="color:#000008;">2、利用 flex 布局实现两侧固定中间自适应 </span></p>
            <p><span style="color:#000008;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;父盒子设置 display：flex</span>
            </p>
            <p><span style="color:#000008;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;左右盒子设置固定宽高 </span></p>
            <p><span style="color:#000008;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;中间盒子设置 flex：1&nbsp;</span>
            </p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%913%E3%80%81%3A%3Abefore%20%E5%92%8C%3A%3Aafter%20%E4%B8%AD%E5%8F%8C%E5%86%92%E5%8F%B7%E5%92%8C%E5%8D%95%E5%86%92%E5%8F%B7%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E3%80%81%E4%BD%9C%E7%94%A8%EF%BC%9F%C2%A0">
            <strong>3、</strong><strong>伪元素和伪类的区别和作用？</strong></h5>
        <blockquote>
            <ul>
                <li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li>
            </ul>
            <pre data-index="4" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">p</span>::before {<span class="hljs-attr">content</span>:<span class="hljs-string">"第一章："</span>;}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">p</span>::after {<span class="hljs-attr">content</span>:<span class="hljs-string">"Hot!"</span>;}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">p</span>::first-line {<span class="hljs-attr">background</span>:red;}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">p</span>::first-letter {font-<span class="hljs-attr">size</span>:30px;}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <ul>
                <li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li>
            </ul>
            <pre data-index="5" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">a</span>:hover {<span class="hljs-attr">color</span>: #<span class="hljs-title class_">FF00FF</span>}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-attr">p</span>:first-child {<span class="hljs-attr">color</span>: red}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p><strong>总结：</strong>&nbsp;伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。</p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%914%E3%80%81img%20%E7%9A%84%20alt%20%E4%B8%8E%20title%20%E7%9A%84%E5%BC%82%E5%90%8C%EF%BC%8C%E8%BF%98%E6%9C%89%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F">
            <strong>4、</strong><span style="color:#000008;">img 的 alt 与 title 的异同，还有实现图片懒加载的原理</span><span
                style="color:#000000;">？</span></h5>
        <blockquote>
            <ul>
                <li><span style="color:#000008;"><strong>异同 </strong></span></li>
            </ul>
            <p><span style="color:#000008;">alt 是图片加载失败时，显示在网页上的替代文字； title 是鼠标放上面时显示的文字,title </span></p>
            <p><span style="color:#000008;">是对图片的描述与进一步说明; </span></p>
            <p><span style="color:#000008;">这些都是表面上的区别，alt 是 img 必要的属性，而 title 不是 对于网站 seo 优化来说，title 与 alt 还有最重要的一点：
                    搜索引擎对图片意思的判断，主 要靠 alt 属性。所以在图片 alt 属性中以简要文字说明，同时包含关键词，也是页面优化的 一部分。条件允许的话，可以在 title 属性里，进一步对图片说明
                    由于过多的图片会严重影响网页的加载速度，并且移动网络下的流量消耗巨大，所以 说延迟加载几乎是标配了。</span></p>
            <ul>
                <li><span style="color:#000008;"><strong>原理 </strong></span></li>
            </ul>
            <p><span style="color:#000008;">图片懒加载的原理很简单，就是我们先设置图片的 data-set 属性（当然也可以是其他任意的， 只要不会发送 http
                    请求就行了，作用就是为了存取值）值为其图片路径，由于不是 src，所 以不会发送 http 请求。 然后我们计算出页面 scrollTop 的高度和浏览器的高度之和， 如果 图片距离页面顶端的坐标
                    Y（相对于整个页面，而不是浏览器窗口）小于前两者之和，就说明图片就要显示出来了（合适的时机，当然也可以是 其他情况），这时候我们再将data-set 属性替换为 src 属性即可。</span>
            </p>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%915%E3%80%81BFC%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0">
            <strong>5、</strong><span style="color:#000008;">BFC 是什么？</span>&nbsp;</h5>
        <blockquote>
            <ul>
                <li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">定义
                            </span></strong></span></li>
            </ul>
            <p><span style="color:#000008;"><strong>BFC (Block formatting
                        context)&nbsp;</strong>直译为&nbsp;<strong>"块级格式化上下文"</strong>。它是一个独立的渲染区域， </span></p>
            <p><span style="color:#000008;">只有 Block-level box 参与，它规定了内部的 Block-level Box 如何布局，并且与这个区 </span></p>
            <p><span style="color:#000008;">域外部毫不相干。</span></p>
            <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">布局规则 </span></strong></span>
            </p>
            <ul>
                <li><span style="color:#000008;">1、内部的 Box 会在垂直方向，一个接一个地放置 </span></li>
                <li><span style="color:#000008;">2、Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin </span></li>
                <li><span style="color:#000008;">会发生重叠 </span></li>
                <li><span style="color:#000008;">3、每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往 </span></li>
                <li><span style="color:#000008;">右的格式化，否则相反)。即使存在浮动也是如此 </span></li>
                <li><span style="color:#000008;">4、BFC 的区域不会与 float box 重叠 </span></li>
                <li><span style="color:#000008;">5、BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反</span><span
                        style="color:#000008;">之也如此 </span></li>
                <li><span style="color:#000008;">6、计算 BFC 的高度时，浮动元素也参与计算 </span></li>
            </ul>
            <p><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">哪些元素会生成
                            BFC</span></strong></span></p>
            <ul>
                <li><span style="color:#000008;">1、根元素 </span></li>
                <li><span style="color:#000008;">2、float 属性不为 none </span></li>
                <li><span style="color:#000008;">3、position 为 absolute 或 fixed </span></li>
                <li><span style="color:#000008;">4、display 为 inline-block， table-cell， table-caption， flex， inline-flex
                    </span></li>
                <li><span style="color:#000008;">5、overflow 不为 visible</span></li>
            </ul>
        </blockquote>
        <h4 id="%E5%9B%9B%E3%80%81JavaScript%E7%AF%87"><a name="t3"></a><span
                style="color:#0d0016;"><strong>四、</strong>JavaScript篇</span></h4>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%20JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"
            style="text-align:justify;"><strong>1、JS基础类型和复杂类型</strong></h5>
        <blockquote>
            <ul>
                <li><strong><span style="color:#333333;">JS数据基础类型有：</span></strong></li>
            </ul>
            <p><strong><span
                        style="color:#333333;">String、Number、Boolean、Null、undefined五种基本数据类型，加上新增的两种ES6的类型Symbol、BigInt</span></strong>
            </p>
            <p></p>
            <ul>
                <li><strong>JS有三种&nbsp;复杂类型 （引用数据类型）：&nbsp;</strong></li>
            </ul>
            <p><strong><span style="color:#333333;">Object（对象）、Array（数组）、function（函数）</span></strong></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%911%E3%80%81%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">
            2、<strong>箭头函数与普通函数的区别？</strong></h5>
        <blockquote>
            <p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">(1)
                            箭头函数比普通函数更加简洁</span></span></strong><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果没有参数 , 就直接写一个空括号即可 , 如果只有一个参数 , 可以省去参数的括号 &nbsp;&nbsp;
                &nbsp;如果有多个参数 , 用逗号分割 , 如果函数体的返回值只有一句 , 可以省略大括号。<br><strong><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">(2) 箭头函数没有自己的this</span></span></strong><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;箭头函数不会创建自己的this, 所以它没有自己的this,
                它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了, 之后不会改变。<br><strong><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">(3)&nbsp;箭头函数继承来的this指向永远不会改变</span><br><span
                            style="background-color:#fef2f0;">(4) call()、apply()、bind()等方法不能改变箭头函数中this的指向
                            &nbsp;</span><br><span style="background-color:#fef2f0;">(5)
                            箭头函数不能作为构造函数使用</span></span></strong><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于箭头函数时没有自己的this，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。&nbsp;<br><strong><span
                        style="color:#be191c;"><span style="background-color:#fef2f0;">(6)
                            箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。&nbsp;</span></span><br><span
                        style="color:#be191c;"><span style="background-color:#fef2f0;">(7)
                            箭头函数没有prototype&nbsp;</span><br><span style="background-color:#fef2f0;">(8)
                            补充：箭头函数的this指向哪⾥？</span></span></strong><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的
                this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>
        </blockquote>
        <h5
            id="%F0%9F%8D%872.JS%E4%B8%ADnull%E5%92%8Cundefined%E7%9A%84%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB%EF%BC%9F">
            3、JS中null和undefined的判断方法和区别？</h5>
        <blockquote>
            <p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">1.undefined
                            的判断</span></span><span style="color:#1c7331;"><span
                            style="background-color:#fef2f0;">　</span></span></strong><br> (1)
                undefined表示缺少值，即此处应该有值，但是还没有定义<br> (2) 变量被声明了还没有赋值，就为undefined<br> (3)
                调用函数时应该提供的参数还没有提供，该参数就等于undefined<br> (4) 对象没有赋值的属性，该属性的值就等于undefined<br> (5)
                函数没有返回值，默认返回undefined<br><strong><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">2.null 的判断　</span></span></strong><br> (1)
                null表示一个值被定义了，但是这个值是空值<br> (2) 作为函数的参数，表示函数的参数不是对象<br> (3) 作为对象原型链的终点
                （Object.getPrototypeOf(Object.prototype)）<br> (4) 定义一个值为null是合理的，但定义为undefined不合理（var name =
                null）<br><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">3.typeof
                            类型不同　　</span></span></strong></p>
            <pre data-index="6" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 'object'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// 'undefined'</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:0,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box0"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p><strong><span style="color:#be191c;"><span style="background-color:#fef2f0;">4.Number()
                            转数字也不同　</span></span></strong></p>
            <pre data-index="7" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 0</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// NaN&nbsp;</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-view="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:1,&quot;ab&quot;:&quot;exp1&quot;}}" data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:1,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box1"><i></i>运行<div><button>运行</button></div></div></div></pre>
        </blockquote>
        <h5 id="%F0%9F%8D%873%E3%80%81%E5%8E%9F%E5%9E%8B%E9%93%BE">4、原型链</h5>
        <blockquote>
            <p><strong><span style="color:#be191c;"><span
                            style="background-color:#fef2f0;">前提须知：</span></span></strong><br>
                (1)&nbsp;<strong>prototype</strong>：<strong>所有的函数</strong>都有原型prototype属性，这个属性指向函数的原型对象。<br>
                (2)&nbsp;<strong>__proto__</strong>，这是每个对象(除null外)都会有的属性，叫做__proto__，这个属性会指向该对象的原型。<br>
                (3)&nbsp;<strong>constructor</strong>: 每个原型都有一个constructor属性，指向该关联的构造函数。</p>
            <p></p>
            <p><strong>原型链：</strong><span
                    style="color:#fe2c24;">获取对象时，如果这个对象上本身没有这个属性时，它就会去它的原型__proto__上去找，如果还找不到，就去原型的原型上去找...一直直到找到最顶层（Object.prototype）为止，Object.prototype对象也有__proto__属性，值为null</span><br>
                此外，每一个prototype原型上都会有一个constructor属性，指向它关联的构造函数。</p>
            <p><br><img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/10c98f521b4ac3300811c4d2b6f6e996.png"></p>
        </blockquote>
        <h5 id="%C2%A0%F0%9F%8D%874%E3%80%81v-show%20%E4%B8%8E%20v-if%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">5、v-show 与
            v-if 的区别？</h5>
        <blockquote>
            <ul>
                <li>
                    <p><strong><span
                                style="color:#be191c;"><code><span style="background-color:#fbd4d0;">v-show</span></code></span></strong>指令是通过修改元素的<code>display</code>的<code>CSS</code>属性让其显示或者隐藏；
                    </p>
                </li>
                <li>
                    <p><strong><span
                                style="color:#be191c;"><code><span style="background-color:#fbd4d0;">v-if</span></code></span></strong>指令是直接&nbsp;<strong>销毁&nbsp;</strong>和&nbsp;<strong>重建&nbsp;</strong><code>DOM</code>达到让元素显示和隐藏的效果；
                    </p>
                </li>
                <li>
                    <p>使用&nbsp;<code>v-show</code>会更加节省性能上的开销；当只需要一次显示或隐藏时，使用<code>v-if</code>更加合理。</p>
                </li>
            </ul>
        </blockquote>
        <h5 id="%F0%9F%8D%875%E3%80%81keep-alive%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%3F">
            6、keep-alive 的作用是什么?</h5>
        <blockquote>
            <ol>
                <li><strong>官网解释：</strong>包裹动态组件时，会缓存不活动的组件实例，主要用于<strong>保留组件状态</strong>或<strong>避免重新渲染</strong>。</li>
                <li><strong>作用：</strong>实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。 需要缓存组件 频繁切换，不需要重复渲染。</li>
                <li><strong>场景：</strong>tabs标签页 后台导航，vue性能优化。</li>
                <li><strong>原理：</strong><code>Vue.js</code>内部将<code>DOM</code>节点抽象成了一个个的<code>VNode</code>节点，<code>keep-alive</code>组件的缓存也是基于<code>VNode</code>节点的而不是直接存储<code>DOM</code>结构。它将满足条件<code>（pruneCache与pruneCache）</code>的组件在<code>cache</code>对象中缓存起来，在需要重新渲染的时候再将<code>vnode</code>节点从<code>cache</code>对象中取出并渲染。
                </li>
            </ol>
        </blockquote>
        <h5 id="%F0%9F%8D%876%E3%80%81%E9%97%AD%E5%8C%85%E7%9A%84%E7%90%86%E8%A7%A3%3F">7、闭包的理解?</h5>
        <blockquote>
            <ul>
                <li><strong>概念：</strong>有权访问另一个函数内部变量的函数。</li>
                <li><strong>本质：</strong><span
                        style="color:#fe2c24;">是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量，利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</span>
                </li>
                <li><strong>面试：什么是闭包？</strong></li>
            </ul>
            <p><strong>&nbsp; &nbsp;
                    通俗的来说：闭包是在一个函数内部在定一个函数，然后内部函数访问外部函数的一个变量就会形成闭包，闭包的话会形成一个私有空间，然后避免全局变量的一个污染，然后会持久化存储数据到内存中，但是闭包也有弊端，它会导致内存泄漏</strong>
            </p>
            <ul>
                <li><strong>拓展：内存泄漏怎么解决？</strong></li>
            </ul>
            <p>首先避免它的使用，其次的话就是变量执行完以后，可以让它赋值为null，最后利用JS的一个垃圾回收机制进行回收</p>
            <ul>
                <li><strong>闭包用处：</strong></li>
            </ul>
            <ol>
                <li>读取内部函数的变量；</li>
                <li>这些变量的值始终会保持在内存中，不会在外层函数调用后被自动清除</li>
            </ol>
            <ul>
                <li><strong>闭包优点：</strong></li>
            </ul>
            <ol>
                <li>变量会一直在内存中；&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                <li>避免全局变量的污染；</li>
                <li>私有变量的存在；</li>
            </ol>
            <ul>
                <li><strong>闭包缺点</strong>：</li>
            </ul>
            <p>&nbsp; &nbsp; 变量长期储存在内存中，会增大内存的使用量，使用不当会造成<strong>内存泄露</strong></p>
            <ul>
                <li><strong>判断闭包的3个特点：</strong></li>
            </ul>
            <p>　　1.函数嵌套函数；</p>
            <p>　　2.内部函数一定操作了外部函数的局部变量；</p>
            <p>　　3.外部函数一定将内部函数返回到外部并保存在一个全局变量中；</p>
            <ul>
                <li><strong>判断闭包的执行结果：</strong></li>
            </ul>
            <p>　　1.外部函数被调用了几次就有几个受保护的局部变量的副本；</p>
            <p>　　2.来自一个闭包的函数被调用几次，受保护的局部变量就变化几次；</p>
            <ul>
                <li><strong>闭包特性：</strong></li>
            </ul>
            <ol>
                <li>函数嵌套函数；</li>
                <li>内部函数可以直接使用外部函数的局部变量；</li>
                <li>变量或参数不会被垃圾回收机制回收；</li>
            </ol>
        </blockquote>
        <h5 id="8%E3%80%81JS%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6">8、JS垃圾回收机制</h5>
        <blockquote>
            <ul>
                <li>垃圾回收机制（Garbage Collection）简称<strong>GC</strong>：是JavaScript中使用的<strong>内存管理系统</strong>的基本组成部分</li>
                <li>JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时会<strong> “自动”
                        释放</strong>、释放的过程成为<strong>垃圾回收</strong></li>
                <li><strong>内存在不使用的时候会被垃圾回收器自动回收</strong></li>
            </ul>
        </blockquote>
        <h5 id="%F0%9F%8D%878%E3%80%81nextTick%E7%9A%84%E5%AE%9E%E7%8E%B0">9、nextTick的实现？</h5>
        <blockquote>
            <ul>
                <li><code>nextTick是Vue提供的一个全局API,是在下次DOM更新循环结束之后执行延迟回调，在修改数据之后使用$nextTick，<span style="color:#1c7331;">则可以在回调中获取更新后的DOM。</span></code>
                </li>
                <li><code>Vue在更新DOM时是异步执行的。只要侦听到数据变化，Vue将开启1个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个watcher被多次触发，只会被推入到队列中-次。这种在缓冲时去除重复数据对于避免不必要的计算和DOM操作是非常重要的。nextTick方法会在队列中加入一个回调函数，确保该函数在前面的dom操作完成后才调用</code>
                </li>
                <li><code>比如，我在干什么的时候就会使用nextTick，传一个回调函数进去，在里面执行dom操作即可。</code><code>简单了解nextTick的实现，它会在callbacks里面加入我们传入的函数，然后用timerFunc异步方式调用它们，首选的异步方式会是Promise。这让我明白了为什么可以在nextTick中看到dom操作结果。</code>
                </li>
                <li>
                    <p><strong>实现原理：</strong>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用 nextTick 来获取更新后的 DOM。
                        nextTick主要使用了宏任务和微任务。
                        根据执行环境分别尝试采用Promise、MutationObserver、setImmediate，如果以上都不行则采用setTimeout定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。
                    </p>
                </li>
            </ul>
        </blockquote>
        <h5 id="%F0%9F%8D%879%E3%80%81mixin%E5%8E%9F%E7%90%86">10、混入mixin的原理？</h5>
        <blockquote>
            <p>mixin 项目变得复杂的时候，多个组件间有重复的逻辑就会用到mixin<br>
                多个组件有相同的逻辑，抽离出来，其实mixin并不是完美的解决方案，会存在一些问题<br><strong>如：vue3提出的Composition
                    API旨在解决这些问题【追求完美是要消耗一定的成本的，如开发成本】</strong><br> 场景：PC端新闻列表和详情页一样的右侧栏目，可以使用mixin进行混合<br><span
                    style="color:#be191c;"><strong><span style="background-color:#fef2f0;">劣势：</span></strong></span>
            </p>
            <ul>
                <li><strong>1. 变量来源不明确，不利于阅读</strong></li>
                <li><strong>2. 多mixin可能会造成命名冲突</strong></li>
                <li><strong>3. mixin和组件可能出现多对多的关系，使得项目复杂度变高</strong></li>
            </ul>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9110%E3%80%81%E5%88%97%E4%B8%BE%E5%92%8C%E6%95%B0%E7%BB%84%E6%93%8D%E4%BD%9C%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%B9%E6%B3%95">
            11、js列举和数组操作相关的方法(常用)</h5>
        <blockquote>
            <p>在JavaScript中，数组操作是编程的常见任务之一。JavaScript提供了一系列与数组操作相关的方法，这些方法可以用来操纵数组，如添加、删除、查找、排序和遍历元素等。以下是一些常用的数组方法：</p>
            <h4><a name="t4"></a>添加元素</h4>
            <ul>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">push()</span></code></strong></span>:
                    在数组的<span style="color:#fe2c24;">末尾</span>添加一个或多个元素，并返回新的长度。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">unshift()</span></code></strong></span>:
                    在数组的<span style="color:#fe2c24;">开头</span>添加一个或多个元素，并返回新的长度。</li>
            </ul>
            <h4><a name="t5"></a>删除元素</h4>
            <ul>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">pop()</span></code></strong></span>:
                    删除数组的<span style="color:#fe2c24;">最后一个元素</span>，并返回那个元素。</li>
                <li><strong><span
                            style="color:#be191c;"><code><span style="background-color:#fef2f0;">shift()</span></code></span></strong>:
                    删除数组的<span style="color:#fe2c24;">第一个元素</span>，并返回那个元素。</li>
                <li><strong><span
                            style="color:#be191c;"><code><span style="background-color:#fef2f0;">splice()</span></code></span></strong>:
                    通过删除、替换或添加新元素来改变数组的内容。</li>
            </ul>
            <h4><a name="t6"></a>查找元素</h4>
            <ul>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">indexOf()</span></code></strong></span>:
                    查找元素在数组中的<span style="color:#fe2c24;">索引</span>。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">lastIndexOf()</span></code></strong></span>:
                    从数组的末尾开始查找元素。</li>
                <li><strong><span
                            style="color:#be191c;"><code><span style="background-color:#fef2f0;">find()</span></code></span></strong>:
                    查找<span style="color:#fe2c24;">第一个满足测试函数的元素</span>。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">findIndex()</span></code></strong></span>:
                    查找<span style="color:#fe2c24;">第一个满足测试函数的元素的索引</span>。</li>
            </ul>
            <h4><a name="t7"></a>排序和翻转</h4>
            <ul>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">sort()</span></code></strong></span>:
                    对数组元素进行排序。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">reverse()</span></code></strong></span>:
                    颠倒反转数组中元素的顺序。</li>
            </ul>
            <h4><a name="t8"></a>遍历和过滤</h4>
            <ul>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">forEach()</span></code></strong></span>:
                    对数组的每个元素执行一次提供的函数。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">map()</span></code></strong></span>:
                    创建一个新数组，其结果是该数组中的每个元素都调用一次提供的函数后的返回值。</li>
                <li><strong><span
                            style="color:#be191c;"><code><span style="background-color:#fef2f0;">filter()</span></code></span></strong>:
                    创建一个新数组，包含通过所提供函数实现的测试的所有元素。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">reduce()</span></code></strong></span>:
                    对数组中的每个元素执行一个由您提供的reducer函数（升序执行），将其结果汇总为单个返回值。</li>
                <li><code>reduceRight()</code>: 类似<code>reduce()</code>，但是从数组的末尾开始累加。</li>
            </ul>
            <h4><a name="t9"></a>归并数组</h4>
            <ul>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">concat()</span></code></strong></span>:
                    合并两个或多个数组。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">slice()</span></code></strong></span>:
                    提取原数组的一部分，返回一个新数组。</li>
            </ul>
            <h4><a name="t10"></a>其它方法</h4>
            <ul>
                <li><strong><span
                            style="color:#be191c;"><code><span style="background-color:#fef2f0;">join()</span></code></span></strong>:
                    将数组（或一个类数组对象）的所有元素连接成一个字符串并返回这个字符串。</li>
                <li><span
                        style="color:#be191c;"><strong><code><span style="background-color:#fef2f0;">toString()</span></code></strong></span>:
                    返回一个表示数组内容的字符串。</li>
                <li><strong><span style="color:#be191c;"><span
                                style="background-color:#fef2f0;">split</span><code><span style="background-color:#fef2f0;">()</span></code></span></strong>:
                    把字符串转换成数组。</li>
                <li><code>toLocaleString()</code>: 返回一个表示数组内容的本地化字符串。</li>
            </ul>
            <p>这些方法可以在日常编程中大大简化数组操作的复杂性。使用这些方法时，需要注意它们的返回值和副作用。例如，<code>push</code> 和 <code>pop</code> 方法会改变原数组，而
                <code>concat</code> 方法则会返回一个新数组。在编写代码时，了解这些方法的特性对于避免不必要的错误和优化性能至关重要。</p>
            <p>&nbsp;<img alt="" height="156"
                    src="https://i-blog.csdnimg.cn/blog_migrate/2742b1d29c9ef51914820711b7085dd5.png" width="635"></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9111%E3%80%81%C2%A0typeof%E5%92%8Cinstanceof%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0">
            12、typeof和instanceof的区别是什么？&nbsp;</h5>
        <blockquote>
            <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#333333;">（1）typeof
                    的返回值是一个字符串，用来说明变量的数据类型；</span></p>
            <p style="margin-left:.0001pt;text-align:justify;"><span
                    style="color:#333333;">typeof用于数据类型的判断，返回值有number、string、boolean、function、undefined、object
                    六个。但是，在其中你会发现，</span><span style="color:#ff0000;">typeof判断null、array、object以及函数的实例（new +
                    函数）时，它返回的都是object。</span><span style="color:#333333;">这就导致在判断这些数据类型的时候得不到真实的数据类型。所以，typeof
                    存在的弊端——它虽然可以判断基本数据类型（null 除外），但是引用数据类型中，除了function 类型以外，其他的也无法判断。</span></p>
            <p style="text-align:justify;"><span
                    style="color:#333333;">（2）instanceof的返回值是布尔值，用于判断一个变量是否属于某个对象的实例。instanceof
                    可以准确地判断复杂引用数据类型，但是不能正确判断基础数据类型。</span></p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9112%E3%80%81js%E4%B8%AD%E2%80%9C%3D%3D%3D%E2%80%9D%20%E5%92%8C%20%E2%80%9C%3D%3D%E2%80%9D%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">
            <span style="color:#000000;">13、</span>JS中 “==“和“===“的区别详解</h5>
        <blockquote>
            <div>
                <p><span style="color:#000008;"><strong>区别 </strong></span></p>
                <ol>
                    <li><span style="color:#be191c;"><strong><span
                                    style="background-color:#fef2f0;">===</span></strong></span><span
                            style="color:#000008;">：三个等号我们称为等同符，当等号两边的值为相同类型的时候，直接比较等号两边 </span><span
                            style="color:#000008;">的值，值相同则返回 true，若等号两边的值类型不同时直接返回 false。</span><span
                            style="color:#000008;">也就是说三个等号</span><span style="color:#be191c;"><span
                                style="background-color:#fef2f0;">既要判断值也要判断类型是否相等</span></span><span
                            style="color:#000008;">。</span></li>
                    <li><span style="color:#be191c;"><strong><span
                                    style="background-color:#fef2f0;">==</span></strong></span><span
                            style="color:#000008;">：两个等号我们称为等值符，当等号两边的值为相同类型时比较值是否相同，类型不同</span><span
                            style="color:#000008;">时会发生类型的自动转换，转换为相同的类型后再作比较。</span><span style="color:#be191c;"><span
                                style="background-color:#fef2f0;">也就是说两个等号只要值相等就可以</span></span><span
                            style="color:#000008;">。</span></li>
                </ol>
            </div>
        </blockquote>
        <h5
            id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%9113%E3%80%81%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%20JavaScript%20%E7%BB%99%E4%B8%80%E4%B8%AA%E6%8C%89%E9%92%AE%E7%BB%91%E5%AE%9A%E4%B8%A4%E4%B8%AA%20onclick%20%E4%BA%8B%E4%BB%B6%EF%BC%9F">
            <span style="color:#000000;">14、如何用原生 JS给一个按钮绑定两个 onclick 事件？</span></h5>
        <blockquote>
            <pre data-index="8" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;button id=<span class="hljs-string">"btn"</span>&gt;点击&lt;/button&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment">//通过事件监听  绑定多个事件</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">let</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">'btn'</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, one)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">'click'</span>, two)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">one</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">'第一个'</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }，</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">two</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">'第二个'</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }，</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%9114%E3%80%81var%20let%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span
                style="color:#000000;">15、var、let和const的区别？</span></h5>
        <blockquote>
            <div class="table-box">
                <table border="1" cellpadding="1" cellspacing="1" style="width:500px;">
                    <tbody>
                        <tr>
                            <td style="width:194px;">区别</td>
                            <td style="width:104px;">var</td>
                            <td style="width:100px;">let</td>
                            <td>const</td>
                        </tr>
                        <tr>
                            <td style="width:194px;">块级作用域</td>
                            <td style="width:104px;">
                                <p>❌</p>
                            </td>
                            <td style="width:100px;">✔️</td>
                            <td>✔️</td>
                        </tr>
                        <tr>
                            <td style="width:194px;">是否存在变量提升</td>
                            <td style="width:104px;">✔️</td>
                            <td style="width:100px;">
                                <p>❌</p>
                            </td>
                            <td>
                                <p>❌</p>
                            </td>
                        </tr>
                        <tr>
                            <td style="width:194px;">是否添加全局属性</td>
                            <td style="width:104px;">✔️</td>
                            <td style="width:100px;">❌</td>
                            <td>❌</td>
                        </tr>
                        <tr>
                            <td style="width:194px;">重复声明同名变量</td>
                            <td style="width:104px;">✔️</td>
                            <td style="width:100px;">❌</td>
                            <td>❌</td>
                        </tr>
                        <tr>
                            <td style="width:194px;">是否存在暂时性死区</td>
                            <td style="width:104px;">❌</td>
                            <td style="width:100px;">✔️</td>
                            <td>✔️</td>
                        </tr>
                        <tr>
                            <td style="width:194px;">是否必须设置初始值</td>
                            <td style="width:104px;">❌</td>
                            <td style="width:100px;">❌</td>
                            <td>✔️</td>
                        </tr>
                        <tr>
                            <td style="width:194px;">能否改变指针方向</td>
                            <td style="width:104px;">✔️</td>
                            <td style="width:100px;">✔️</td>
                            <td>❌</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <strong>（1）块级<strong><a
                        href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&amp;spm=1001.2101.3001.7020"
                        title="作用域">作用域</a></strong>：&nbsp;</strong>
            <span style="color:#4f4f4f;">块作用域由 { }包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了</span>
            <a href="https://so.csdn.net/so/search?q=ES5&amp;spm=1001.2101.3001.7020" title="ES5">ES5</a>
            <span style="color:#4f4f4f;">中的两个问题：</span>
            <ul>
                <li>内层变量可能覆盖外层变量</li>
                <li>用来计数的循环变量泄露为<a
                        href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&amp;spm=1001.2101.3001.7020"
                        title="全局变量">全局变量</a></li>
            </ul>
            <p><strong>（2）变量提升</strong>： var存在<a
                    href="https://so.csdn.net/so/search?q=%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87&amp;spm=1001.2101.3001.7020"
                    title="变量提升">变量提升</a>，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
            <p><strong>（3）给全局添加属性</strong>： 浏览器的全局对象是window，<a
                    href="https://so.csdn.net/so/search?q=Node&amp;spm=1001.2101.3001.7020"
                    title="Node">Node</a>的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
            <p><strong>（4）重复声明</strong>： var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
            <p><strong>（5）暂时性死区</strong>： 在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<a
                    href="https://so.csdn.net/so/search?q=%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA&amp;spm=1001.2101.3001.7020"
                    title="暂时性死区">暂时性死区</a>。使用var声明的变量不存在暂时性死区。</p>
            <p><strong>（6）初始值设置</strong>： 在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
            <p>（7）指针指向： let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9115%E3%80%81%E8%AE%B2%E8%A7%A3js%E7%9A%84call%E3%80%81apply%E5%92%8Cbind%E5%8C%BA%E5%88%AB%EF%BC%9F">
            <span style="color:#000000;">16、</span>讲解js的call、apply和bind区别<span style="color:#000000;">？</span></h5>
        <blockquote>
            <p>首先，call apply bind三个方法都可以用来改变函数的this指向，具体区别如下：</p>
            <ol>
                <li>call( ) 是接收一个及其以上的参数，第一个参数表示this要指向的对象，其余参数表示调用函数需要传入的参数，返回调用函数的返回结果，属于立即执行函数；</li>
                <li>apply( ) 是接收两个参数，第一个参数表示this要指向的对象，第二参数表示调用函数需要传入的参数所组成的数组，返回调用函数的返回结果，属于立即执行函数；</li>
                <li>bind( ) 是接收一个及其以上的参数，和call(）一致，但是其返回是一个函数，而不是调用函数的返回结果</li>
            </ol>
            <ul>
                <li>call、apply、bind相同点：都是改变this的指向，传入的第一个参数都是绑定this的指向，在非严格模式中，如果第一个参数是nul或者undefined，会把全局对象（浏览器是window）作为this的值，要注意的是，在严格模式中，null
                    就是 null，undefined 就是 undefined</li>
                <li><span style="color:#be191c;"><strong><span
                                style="background-color:#fef2f0;">call和apply唯一的区别是：call传入的是参数列表，apply传入的是数组，也可以是类数组</span></strong></span>
                </li>
                <li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">bind和call、apply的区别：
                                bind返回的是一个改变了this指向的函数，便于稍后调用，不像call和apply会立即调用；bind和call很像，传入的也是参数列表，但是可以多次传入，不需要像call，一次传入</span></strong></span>
                </li>
                <li>值得注意：当 bind 返回的函数 使用new作为构造函数时，绑定的 this 值会失效，this指向实例对象，但传入的参数依然生效 （new调用的优先级 &gt; bind调用）</li>
            </ul>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%9116%E3%80%81%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F">
            <span style="color:#0d0016;"><strong>17、</strong></span><span style="color:#000000;">谈谈你对webpack的理解？</span>
        </h5>
        <blockquote>
            <p><img alt="" height="453"
                    src="https://i-blog.csdnimg.cn/blog_migrate/60321cc57f4b99e1c4964b7642ca253b.png" width="675"></p>
            <p><strong>1、谈谈你对Webpack的理解</strong></p>
            <ul>
                <li>Webpack是一个模块打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件。</li>
                <li>它可以很好地管理、打包开发中所用到的HTML,CSS,JavaScript和静态文件（图片，字体）等，让开发更高效。</li>
                <li>对于不同类型的依赖，Webpack有对应的模块加载器，而且会分析模块间的依赖关系，最后合并生成优化的静态资源。</li>
            </ul>
            <p><strong>2、Webpack的基本功能有哪些？</strong></p>
            <ul>
                <li>代码转换：TypeScript 编译成 JavaScript、SCSS 编译成 CSS 等等</li>
                <li>文件优化：压缩 JavaScript、CSS、HTML 代码，压缩合并图片等</li>
                <li>代码分割：提取多个页面的公共代码、提取首屏不需要执行部分的代码让其异步加载</li>
                <li>模块合并：在采用模块化的项目有很多模块和文件，需要构建功能把模块分类合并成一个文件</li>
                <li>自动刷新：监听本地源代码的变化，自动构建，刷新浏览器</li>
                <li>代码校验：在代码被提交到仓库前需要检测代码是否符合规范，以及单元测试是否通过</li>
                <li>自动发布：更新完代码后，自动构建出线上发布代码并传输给发布系统。</li>
            </ul>
            <p><strong>3、Webpack构建过程？</strong></p>
            <ul>
                <li>从entry里配置的module开始递归解析entry依赖的所有module</li>
                <li>每找到一个module，就会根据配置的loader去找对应的转换规则</li>
                <li>对module进行转换后，再解析出当前module依赖的module</li>
                <li>这些模块会以entry为单位分组，一个entry和其所有依赖的module被分到一个组Chunk</li>
                <li>最后Webpack会把所有Chunk转换成文件输出在整个流程中Webpack会在恰当的时机执行plugin里定义的逻辑</li>
            </ul>
            <p><strong>4、有哪些常见的Loader?</strong></p>
            <ul>
                <li>optimize-css-assets-plugin：压缩css；</li>
                <li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)</li>
                <li>url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)
                </li>
                <li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li>
                <li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li>
                <li>json-loader: 加载 JSON 文件（默认包含）</li>
                <li>ts-loader: babel-loader：把 ES6 转换成 ES5</li>
                <li>ts-loader: 将 TypeScript 转换成 JavaScript</li>
                <li>less-loader：将less代码转换成CSS</li>
                <li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
                <li>vue-loader:加载 Vue单文件组件</li>
            </ul>
            <p><strong>5、有哪些常见的Plugin？</strong></p>
            <p>1、html-webpack-plugin</p>
            <p>用途：自动创建一个 HTML 文件，并将打包好的 JavaScript 文件插入到这个 HTML 文件中。<br> 配置示例：</p>
            <pre data-index="9" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> <span class="hljs-title class_">HtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">plugins</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>({</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">template</span>: <span class="hljs-string">'./src/index.html'</span>, <span class="hljs-comment">// 使用现有的 HTML 文件作为模板</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">filename</span>: <span class="hljs-string">'index.html'</span>, <span class="hljs-comment">// 输出的 HTML 文件名</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">inject</span>: <span class="hljs-string">'body'</span> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  })</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:2,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box2"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p>2、uglifyjs-webpack-plugin<br> 用途：压缩 JavaScript 文件。需要注意的是，UglifyJS 不支持 ES6+ 代码压缩。如果你需要压缩 ES6+ 代码，可以考虑使用
                terser-webpack-plugin<br> 配置示例 (Webpack 4 及以前)：</p>
            <pre data-index="10" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UglifyJsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'uglifyjs-webpack-plugin'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">optimization</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">UglifyJsPlugin</span>()]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:3,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box3"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p>3、mini-css-extract-plugin</p>
            <p>用途: 在构建过程中将 CSS 代码从 JavaScript 打包文件中抽离出来，单独生成一个或多个 CSS 文件。这样可以提高页面加载性能，因为浏览器可以并行加载 CSS 和 JavaScript 文件。
            </p>
            <p>配置示例:</p>
            <pre data-index="11" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MiniCssExtractPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">module</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">rules</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-attr">use</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          <span class="hljs-title class_">MiniCssExtractPlugin</span>.<span class="hljs-property">loader</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          <span class="hljs-string">'css-loader'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-attr">plugins</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MiniCssExtractPlugin</span>({</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">filename</span>: <span class="hljs-string">'[name].css'</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">'[id].css'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    })</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:4,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box4"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p>4、clean-webpack-plugin:<br> 用途: 在每次构建之前清理输出目录，删除整个输出文件夹下的内容。这有助于避免旧的文件干扰新的构建结果，确保每次构建都是基于最新的源代码。<br>
                配置示例:</p>
            <pre data-index="12" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">CleanWebpackPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'clean-webpack-plugin'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">plugins</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CleanWebpackPlugin</span>()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:5,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box5"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p>5、copy-webpack-plugin<br>
                &ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;用途:
                用于将项目中的文件或文件夹复制到构建输出目录中。<br> 配置示例:</p>
            <pre data-index="13" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:822px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> <span class="hljs-title class_">CopyWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'copy-webpack-plugin'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">plugins</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyWebpackPlugin</span>({</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">patterns</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        { <span class="hljs-attr">from</span>: <span class="hljs-string">'src/assets'</span>, <span class="hljs-attr">to</span>: <span class="hljs-string">'assets'</span> } <span class="hljs-comment">// 将 src/assets 文件夹复制到输出目录的 assets 文件夹中</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    })</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:6,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box6"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p>6、webpack-bundle-analyzer<br>
                &ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;&ZeroWidthSpace;用途:
                可视化 Webpack 输出文件的体积，帮助你分析业务组件和依赖的第三方模块的大小。<br> 配置示例:</p>
            <pre data-index="14" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> { <span class="hljs-title class_">BundleAnalyzerPlugin</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-bundle-analyzer'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">plugins</span>: [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">new</span> <span class="hljs-title class_">BundleAnalyzerPlugin</span>()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p>7、optimize-css-assets-plugin<br> 用途: 压缩 CSS 文件，减少文件大小。<br> 配置示例:</p>
            <pre data-index="15" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">optimization</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">minimizer</span>: [<span class="hljs-keyword">new</span> <span class="hljs-title class_">OptimizeCSSAssetsPlugin</span>()]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:7,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box7"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p><strong>6、那你再说一说Loader和Plugin的区别？</strong></p>
            <ul>
                <li>Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader
                    就成了翻译官，对其他类型的资源进行转译的预处理工作。</li>
                <li>Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过
                    Webpack 提供的 API 改变输出结果。</li>
                <li>Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。
                </li>
                <li>Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。</li>
            </ul>
            <p><strong>7、如何优化 Webpack 的构建速度？</strong></p>
            <p>（1）使用高版本的 Webpack 和 <span class="words-blog hl-git-1" data-tit="Node" data-pretit="node">Node</span>.js
            </p>
            <p>（2）压缩代码</p>
            <ul>
                <li>通过 uglifyjs-webpack-plugin 压缩JS代码</li>
                <li>通过 mini-css-extract-plugin 提取 chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。
                </li>
            </ul>
            <p>（3）多线程/多进程构建：thread-loader, HappyPack</p>
            <p>（4）压缩图片: <span class="words-blog hl-git-1" data-tit="image"
                    data-pretit="image">image</span>-webpack-loader</p>
            <p>（5）缩小打包作用域</p>
            <ul>
                <li>exclude/include (确定 loader 规则范围)</li>
                <li>resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)</li>
                <li>resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)</li>
                <li>resolve.extensions 尽可能减少后缀尝试的可能性</li>
                <li>noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)</li>
                <li>ignorePlugin (完全排除模块)</li>
            </ul>
            <p><strong>8、说一下 Webpack 的热更新原理吧？</strong></p>
            <ul>
                <li>Webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。</li>
                <li>HMR的核心就是客户端从服务端拉去更新后的文件，准确地说是 chunk diff (chunk 需要更新的部分)，实际上 WDS 与浏览器之间维护了一个
                    Websocket，当本地资源发生变化时，WDS 会向浏览器推送更新，并带上构建时的 hash，让客户端与上一次资源进行对比。客户端对比出差异后会向 WDS 发起 Ajax
                    请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向 WDS 发起 jsonp 请求获取该chunk的增量更新。</li>
                <li>后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，提供了相关 API
                    以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。</li>
            </ul>
            <p><strong>9、什么是bundle？什么是chunk？什么是module？</strong></p>
            <ul>
                <li>bundle：是webpack打包后的一个文件；</li>
                <li>chunk：代码块，一个chunk 可能有很多的模块组成，用于合并和分割代码；</li>
                <li>module：模块，在webpack中，一切都是模块，一个文件就是一个模块，她从入口开始查找webpack依赖的所有模块</li>
            </ul>
            <p><strong>10、webpack和grunt以及gulp有什么不同？</strong></p>
            <ul>
                <li>grunt和gulp是基于任务处理的工具，我们需要把我们要做的事分配成各种各样的任务，grunt和gulp会自动执行各种分配的任务，像流水线一样，把资源放上去通过不同的插件进行加工，他的插件非常丰富，能够为我们打造各种工作流；
                </li>
                <li>webpack是模块化打包工具，把所有文件都当作模块进行处理，也就是说webpack和grunt和gulp是两种完全不一样的东西；</li>
            </ul>
        </blockquote>
        <h5
            id="17%E3%80%81%C2%A0const%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%EF%BC%9F">
            18、&nbsp;const定义的对象属性是否可以改变？</h5>
        <blockquote>
            <p><strong>情况一：</strong>const定义的变量存在块级作用域，且不存在变量提升，一般用于定义常量，定义的时候必须初始化。</p>
            <p><strong>答：<span style="color:#fe2c24;">不可以，</span></strong><span
                    style="color:#fe2c24;">const定义的如果是基本数据类型（string，number，boolean，null，undifined，symbol），定义后就<strong>不可再修改</strong>，如果修改，会报错。</span>
            </p>
            <p style="text-align:center;"><span style="color:#fe2c24;"><img alt=""
                        src="https://i-blog.csdnimg.cn/blog_migrate/8fa23533f6123808f0c6c7d9d0a644f3.jpeg"></span></p>
            <p><strong>情况二：</strong>那么如果是const定义的对象呢？是否可以修改对象中的属性？<br><strong>答案：<span
                        style="color:#fe2c24;">可以</span></strong></p>
            <p><span
                    style="color:#fe2c24;"><strong>原因：对象是引用类型的，const定义的对象t中保存的是指向对象t的指针，这里的“不变”指的是指向对象的指针不变，而修改对象中的属性并不会让指向对象的指针发生变化，所以用const定义对象，对象的属性是可以改变的。</strong></span>
            </p>
            <p style="text-align:center;"><span style="color:#fe2c24;"><strong><img alt=""
                            src="https://i-blog.csdnimg.cn/blog_migrate/78b214a4f3e751fb6a1a6116bb257e23.jpeg"></strong></span>
            </p>
        </blockquote>
        <h5
            id="%C2%A018%E3%80%81%E6%89%93%E5%8D%B0%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%8C%E5%87%BA%E7%8E%B0%E6%A0%88%E6%BA%A2%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%EF%BC%9F">
            19、栈溢出及解决方法？</h5>
        <blockquote>
            <p><strong>栈溢出(stack Overflow)</strong></p>
            <ul>
                <li>缓冲区溢出是由于C语言系列设有内置检查机制来确保复制到缓冲区的数据不得大于缓冲区的大小，因此当这个数据足够大的时候，将会溢出缓冲区的范围。</li>
                <li>
                    <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">栈溢出就是缓冲区溢出的一种。</span></span>
                        由于缓冲区溢出而使得有用的存储单元被改写,
                        往往会引发不可预料的后果。程序在运行过程中，为了临时存取数据的需要，一般都要分配一些内存空间，通常称这些空间为缓冲区。如果向缓冲区中写入超过其本身长度的数据，以致于缓冲区无法容纳，就会造成缓冲区以外的存储单元被改写，这种现象就称为缓冲区溢出。缓冲区长度一般与用户自己定义的缓冲变量的类型有关。
                    </p>
                </li>
                <li>
                    <p><span style="color:#be191c;"><span
                                style="background-color:#fef2f0;">由于缓冲区溢出而使得有用的存储单元被改写，</span></span>往往会引发不可预料的后果。向这些单元写入任意的数据，一般只会导致程序崩溃之类的事故，对这种情况我们也至多说这个程序有Bug。但如果向这些单元写入的是精心准备好的数据，就可能使得程序流程被劫持，致使不希望的代码被执行，落入攻击者的掌控之中，这就不仅仅是bug，而是漏洞(exploit)了。
                    </p>
                </li>
            </ul>
            <p><strong>栈溢出的解决方法</strong></p>
            <ul>
                <li>减少栈空间的需求，<span
                        style="color:#be191c;"><code><span style="background-color:#fef2f0;">不要定义占用内存较多的auto变量</span></code></span>，应该将此类变量修改成指针，<span
                        style="color:#be191c;"><code><span style="background-color:#fef2f0;">从堆空间分配内存</span></code></span>。
                </li>
                <li>函数参数中不要传递大型结构/联合/对象，应该使用<span
                        style="color:#be191c;"><code><span style="background-color:#fef2f0;">引用或指针作为函数参数</span></code></span>。
                </li>
                <li>减少函数调用层次，<span
                        style="color:#be191c;"><code><span style="background-color:#fef2f0;">慎用递归函数</span></code></span>，例如A-&gt;B-&gt;C-&gt;A环式调用。
                </li>
            </ul>
        </blockquote>
        <h5 id="20%E3%80%81JS%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F">20、JS如何实现多线程？
        </h5>
        <blockquote>
            <ul>
                <li>什么是JavaScript的多线程？</li>
            </ul>
            <p>JavaScript本身是<strong>单线程</strong>的，但是可以通过实现多线程来提高性能和用户体验。多线程允许JavaScript在等待用户交互或网络请求时，执行其他任务，从而提高页面加载速度和响应速度。
            </p>
            <ul>
                <li>JavaScript中有哪些实现多线程的方式？</li>
            </ul>
            <p>JavaScript有多种实现多线程的方式，包括Web Workers、SharedArrayBuffer、WebAssembly等。其中，Web
                Workers允许在后台线程中运行JavaScript代码，而SharedArrayBuffer和BufferSource API则允许在多个线程之间共享数据。</p>
            <ul>
                <li>如何使用Web Workers实现多线程？</li>
            </ul>
            <p>使用Web
                Workers实现多线程需要创建一个新的worker线程，并将需要执行的代码作为字符串传递给worker。worker线程可以访问全局对象messageChannel的postMessage方法来发送消息，主线程可以使用onmessage方法来接收消息并执行相应的操作。
            </p>
            <ul>
                <li>如何保证多线程安全？</li>
            </ul>
            <p>多线程环境下的安全问题主要包括数据竞争和死锁等。为了解决这些问题，需要使用同步机制，如使用Promise、async/await等异步编程方式，或者使用事件循环、共享内存等机制来保证数据的一致性和安全性。
            </p>
            <ul>
                <li>描述一个实际的多线程应用场景。</li>
            </ul>
            <p>在实际应用中，多线程可以用于提高页面加载速度和响应速度，例如在<a
                    href="https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&amp;spm=1001.2101.3001.7020"
                    target="_blank" class="hl hl-1"
                    data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;word\&quot;:\&quot;电商\&quot;}&quot;}"
                    data-tit="电商" data-pretit="电商">电商</a>网站中，可以使用Web
                Workers在后台线程中加载和处理商品图片，从而提高页面加载速度和用户体验。同时，多个并发请求也可以使用Web Workers并行处理，提高系统性能和响应速度。</p>
        </blockquote>
        <h5
            id="21%E3%80%81%C2%A0%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%8C%BA%E5%88%AB%E6%A6%82%E5%BF%B5%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5%EF%BC%9F">
            21、浅拷贝和深拷贝区别概念常见情况？</h5>
        <blockquote>
            <ul>
                <li><span style="color:#be191c;"><span style="background-color:#fbd4d0;">浅拷贝</span></span></li>
            </ul>
            <ol>
                <li>浅拷贝创建一个新的对象，但是只复制原始对象的基本数据类型的字段或引用（地址），而不复制引用指向的对象。这意味着新对象和原始对象中的引用指向相同的对象。</li>
                <li>如果原始对象中的字段是基本数据类型，那么这些字段会被复制到新对象中，而如果字段是引用类型，则新对象和原始对- 象的对应字段将引用同一个对象。</li>
                <li>因此，对新对象所做的修改可能会影响到原始对象，因为它们共享相同的引用。</li>
            </ol>
            <ul>
                <li><span style="color:#be191c;"><span style="background-color:#fef2f0;">深拷贝</span></span></li>
            </ul>
            <ol>
                <li>深拷贝创建一个新的对象，并且递归地复制原始对象的所有字段和引用指向的对象，而不仅仅是复制引用本身。</li>
                <li>深拷贝会递归复制整个对象结构，包括对象内部的对象，确保新对象和原始对象之间的所有关系都是独立的。</li>
                <li>这意味着对新对象所做的修改不会影响到原始对象，因为它们拥有彼此独立的副本。</li>
            </ol>
            <p><img alt="" height="198"
                    src="https://i-blog.csdnimg.cn/blog_migrate/a25de48320583316234c49ada0b3bc0e.png" width="649"></p>
            <p></p>
            <p>1、基本类没有问题<br> 因为，基本类型赋值时，赋的是数据（所以，不存在深拷贝和浅拷贝的问题）。</p>
            <p><u>&nbsp;例如1：</u><br><span style="color:#1c7331;">&nbsp;&nbsp;&nbsp;&nbsp;var x = 100;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;var y = x; //此时x和y都是100;</span><br> &nbsp;&nbsp;&nbsp;如果要改变y的值，x的值不会改变。</p>
            <p>2、引用类型有问题<br> 因为，引用类型赋值时，赋的值地址（就是引用类型变量在内存中保存的内容）<br><u>&nbsp;例如2：</u><br><span
                    style="color:#1c7331;">var arr1 = new Array(12,23,34)<br> var arr2 = arr1;&nbsp;
                    //这就是一个最简单的浅拷贝</span><br> 如果要改变arr2所引用的数据：arr2[0]=100时，那么arr1[0]的值也是100。<br> 原因就是
                arr1和arr2引用了同一块内存区域（以上的第二点中有体现）。<br> 这是最简单的浅拷贝，因为，只是把arr1的地址拷贝的一份给了arr2，并没有把arr1的数据拷贝一份。所以，拷贝的深度不够。</p>
            <p><span style="color:#fe2c24;"><strong>一、常见的 “浅” 拷贝方法：</strong></span></p>
            <p>除了上面我们演示的对于赋值操作，下面将介绍一些开发中可能会用到，当然也可以会被面试官问到的实现深浅拷贝的方法。</p>
            <p><strong>1. Object.assign()</strong><br> 方法解释：方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象,它将返回目标对象可以实现一个浅拷贝的效果。<br>
                参数一：目标对象<br> 参数二：源对象</p>
            <pre data-index="16" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> obj1 = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-attr">c</span>: [<span class="hljs-string">'c'</span>, <span class="hljs-string">'t'</span>, <span class="hljs-string">'r'</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> obj2 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>({}, obj1);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">obj2.<span class="hljs-property">c</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">obj2.<span class="hljs-property">b</span> = <span class="hljs-number">3</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1); <span class="hljs-comment">// {a:1,b:2,c:["c", 5, "r"]}</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">// {a:1,b:3,c:["c", 5, "r"]}</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj1.<span class="hljs-property">c</span>); <span class="hljs-comment">// ["c", 5, "r"]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2.<span class="hljs-property">c</span>); <span class="hljs-comment">// ["c", 5, "r"]</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p><span
                    style="color:#fe2c24;">注意：可见Object.assign()方法对于一维数据是深拷贝效果，但是对于多维数据是浅拷贝效果。Object.assign是一个浅拷贝,它只是在<strong>根属性</strong>(对象的第一层级)创建了一个新的对象，但是对于属性的值是仍是对象的话依然是浅拷贝，</span>
            </p>
            <p><strong>2. slice()</strong></p>
            <p>方法解释：数组进行截取，如果不传参数,会使用默认值,得到一个与原数组元素相同的新数组。<br> 参数一：截取的起始位置<br> 参数二：截取的结束位置<br> &nbsp;</p>
            <pre data-index="17" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> b = a.<span class="hljs-title function_">slice</span>();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">a[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">b[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// [99,[2,2],3,4]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// [1,[2,2],3,4]</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:8,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box8"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p><span style="color:#fe2c24;">注意：可见slice()方法也只是对一维数据进行深拷贝，但是对于多维的数据还是浅拷贝效果。</span></p>
            <p><strong>3. concat()方法</strong></p>
            <p>方法解释：数组的拼接(将多个数组或元素拼接形成一个新的数组)，不改变原数组，如果不传参数,会使用默认值，得到一个与原数组元素相同的新数组 (复制数组)。<br> &nbsp;</p>
            <pre data-index="18" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> c = [];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> b = c.<span class="hljs-title function_">concat</span>(a);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">a[<span class="hljs-number">0</span>] = <span class="hljs-number">99</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">b[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">88</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// [99,2,[3,88]]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// [1,2,[3,88]]</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:9,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box9"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p><span style="color:#fe2c24;">注意：可见concat()方法也只对一维数据具有深拷贝效果，对于多维的数据任然只是浅拷贝</span></p>
            <p>4. ES6拓展运算符</p>
            <pre data-index="19" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> b = [...a];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">a[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">88</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">b[<span class="hljs-number">1</span>] = <span class="hljs-number">99</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// [1,2,[3,88]]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// [1,99,[3,88]]</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:10,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box10"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p><span style="color:#fe2c24;">注意: 可见ES6的展开运算符对于一维数据是深拷贝效果，但是对于多维数据任然是浅拷贝效果。</span></p>
            <p><span style="color:#fe2c24;"><strong>二、实现 “深” 拷贝常见方法：</strong></span></p>
            <p><a name="t15"></a><a id="1_JSONparseJSONstringifyobj_104"></a><strong>1.
                    JSON.parse(JSON.stringify(obj))</strong></p>
            <p></p>
            <p>JSON.stringify()是目前前端开发过程中最常用的深拷贝方式，原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象
            </p>
            <ul>
                <li>JSON.stringfy() 将对象序列化成json对象</li>
                <li>JSON.parse() 反序列化——将json对象反序列化成js对象</li>
            </ul>
            <pre data-index="20" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepCopy</span>(<span class="hljs-params">obj1</span>){</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">let</span> _obj = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(obj1);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">let</span> obj2 = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(_obj);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> obj2;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> b = <span class="hljs-title function_">deepCopy</span>(a);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">b[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a); <span class="hljs-comment">// 1,1,2,3,4</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b); <span class="hljs-comment">// 1,2,2,3,4</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p><span style="color:#fe2c24;">注意：它会抛弃对象的constructor，深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成Object类型，这种方法能正确处理的对象只有
                    Number, String, Boolean, Array, 扁平对象，<br> 也就是说，只有可以转成JSON格式的对象才可以这样用，像function没办法转成JSON。</span></p>
            <p>2. 使用第三方库实现对象的深拷贝，比如：<strong>lodash、<a href="https://www.jquery123.com/jQuery.extend/" rel="nofollow"
                        title="jQuery">jQuery</a></strong></p>
            <pre data-index="21" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> lodash <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> objects = [<span class="hljs-number">1</span>,{ <span class="hljs-string">'a'</span>: <span class="hljs-number">1</span> }, { <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span> }]; </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> deep = lodash.<span class="hljs-title function_">cloneDeep</span>(objects);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">deep[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">deep[<span class="hljs-number">1</span>].<span class="hljs-property">a</span> = <span class="hljs-number">2</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(objects); <span class="hljs-comment">// [1,{ 'a': 1 }, { 'b': 2 }]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(deep); <span class="hljs-comment">//[2,{ 'a': 2 }, { 'b': 2 }]</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:11,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box11"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p><strong>3. 递归</strong></p>
            <p>这里简单封装了一个deepClone的函数，for
                in遍历传入参数的值，如果值是引用类型则再次调用deepClone函数，并且传入第一次调用deepClone参数的值作为第二次调用deepClone的参数，如果不是引用类型就直接复制</p>
            <pre data-index="22" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> obj1 = {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">a</span>:{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-attr">b</span>:<span class="hljs-number">1</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepClone</span>(<span class="hljs-params">obj</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> cloneObj = {}; <span class="hljs-comment">//在堆内存中新建一个对象</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj){ <span class="hljs-comment">//遍历参数的键</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[key] ===<span class="hljs-string">'object'</span>){ </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">          cloneObj[key] = <span class="hljs-title function_">deepClone</span>(obj[key]) <span class="hljs-comment">//值是对象就再次调用函数</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">       }<span class="hljs-keyword">else</span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">           cloneObj[key] = obj[key] <span class="hljs-comment">//基本类型直接复制值</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">       }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> cloneObj </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> obj2 = <span class="hljs-title function_">deepClone</span>(obj1);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">obj1.<span class="hljs-property">a</span>.<span class="hljs-property">b</span> = <span class="hljs-number">2</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj2); <span class="hljs-comment">//{a:{b:1}}</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:12,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box12"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p>但是还有很多问题</p>
            <ul>
                <li>首先这个deepClone函数并不能复制不可枚举的属性以及Symbol类型</li>
                <li>这里只是针对Object引用类型的值做的循环迭代，而对于Array,Date,RegExp,Error,Function引用类型无法正确拷贝</li>
                <li>对象循环引用成环了的情况</li>
            </ul>
        </blockquote>
        <h5 id="22%E3%80%81promise%E5%92%8Casync%EF%BC%8Cawait%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%C2%A0">
            22、事件循环，Promise和async/await的详解</h5>
        <blockquote>
            <p><strong><code>事件循环event loop</code>它的执行顺序：</strong></p>
            <ul>
                <li>一开始整个脚本作为一个宏任务执行</li>
                <li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li>
                <li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完</li>
                <li>执行浏览器UI线程的渲染工作</li>
                <li>检查是否有<code>Web Worker</code>任务，有则执行</li>
                <li>执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空</li>
            </ul>
            <p><strong>微任务包括：</strong><span
                    style="color:#be191c;"><code><span style="background-color:#fef2f0;">MutationObserver</span></code><span
                        style="background-color:#fef2f0;">、</span><code><span style="background-color:#fef2f0;">Promise.then()或catch()</span></code><span
                        style="background-color:#fef2f0;">、</span></span><code><span style="color:#be191c;"><span style="background-color:#fef2f0;">Promise</span></span>为基础开发的其它技术，比如fetch API</code>、<code>V8</code>的垃圾回收过程、<code>Node独有的process.nextTick</code>。
            </p>
            <p><strong>宏任务包括</strong>：<span
                    style="color:#be191c;"><code><span style="background-color:#fef2f0;">script</span></code><span
                        style="background-color:#fef2f0;">
                        、</span><code><span style="background-color:#fef2f0;">setTimeout</span></code><span
                        style="background-color:#fef2f0;">、</span><code><span style="background-color:#fef2f0;">setInterval</span></code><span
                        style="background-color:#fef2f0;">
                        、</span><code><span style="background-color:#fef2f0;">setImmediate</span></code><span
                        style="background-color:#fef2f0;">
                        、</span><code><span style="background-color:#fef2f0;">I/O</span></code><span
                        style="background-color:#fef2f0;">
                        、</span><code><span style="background-color:#fef2f0;">UI rendering</span></code><span
                        style="background-color:#fef2f0;">。</span></span></p>
            <p><strong>注意</strong>⚠️：在所有任务开始的时候，由于宏任务中包括了<code>script</code>，所以浏览器会先执行一个宏任务，在这个过程中你看到的延迟任务(例如<code>setTimeout</code>)将被放到下一轮宏任务中来执行。
            </p>
            <p>Promise和async/await是JavaScript中处理异步操作的两种方式。</p>
            <ol>
                <li>Promise是一种用于处理异步操作的对象。它可以表示一个异步操作的最终完成或失败，并返回相应的结果或错误信息。Promise有三种状态：pending（进行中）、fulfilled（已完成）和rejected（已拒绝）。通过调用Promise的then()方法可以注册回调函数来处理异步操作的结果。
                </li>
                <li>async/await是ES8引入的一种更加简洁的处理异步操作的方式。async函数是一个返回Promise对象的函数，其中可以使用await关键字来等待一个Promise对象的解决。await关键字可以暂停async函数的执行，直到Promise对象解决为止，并返回解决后的结果。
                </li>
            </ol>
            <p><span style="color:#0d0016;"><strong>区别：</strong></span></p>
            <ul>
                <li>- 语法上，Promise使用then()和catch()方法来处理异步操作的结果，而async/await使用async函数和await关键字来等待异步操作的结果。</li>
                <li>- 可读性上，async/await更加直观和易于理解，代码结构更加清晰，而Promise则需要通过链式调用then()方法来处理多个异步操作。</li>
                <li>- 错误处理上，Promise使用catch()方法来捕获错误，而async/await可以使用try-catch语句来捕获错误。</li>
            </ul>
            <p>详细解答：</p>
            <ul>
                <li>JavaScript的异步机制包括以下几个步骤：</li>
            </ul>
            <pre data-index="23" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:1132px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（<span class="hljs-number">1</span>）所有同步任务都在主线程上执行，行成一个执行栈</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（<span class="hljs-number">2</span>）主线程之外，还存在一个任务队列，只要异步任务有了结果，就会在任务队列中放置一个事件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（<span class="hljs-number">3</span>）一旦执行栈中的所有同步任务执行完毕，系统就会读取任务队列，看看里面还有哪些事件，哪些对应的异步任务，于是异步任务结束等待状态，进入执行栈，开始执行</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">（<span class="hljs-number">4</span>）主线程不断的重复上面的第三步</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:13,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box13"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <ol>
                <li>promise的用法</li>
            </ol>
            <p>Promise,简单来说就是一个容器，里面保存着某个未来才会结束的时间(通常是一个异步操作的结果)</p>
            <ul>
                <li><strong>基本语法</strong></li>
            </ul>
            <pre data-index="24" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-comment">//...</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'success'</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    });</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> obj.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">//success</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> });</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:14,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box14"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <ul>
                <li>
                    <p><strong>promise共有三个状态</strong></p>
                </li>
            </ul>
            <p>pending（执行中）、resolve（成功）、rejected（失败）</p>
            <ul>
                <li><strong>链式调用</strong></li>
            </ul>
            <p><a href="https://m.baidu.com/s?word=Promise%20%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8&amp;sa=re_dqa_zy"
                    rel="nofollow" title="Promise 链式调用">Promise 链式调用</a>是一种编程模式，允许在异步操作之间顺序执行多个操作。在每个操作中，可以使用
                `.then()` 方法返回一个新的 Promise，从而在异步流程中继续执行下一个操作。这样可以避免回调函数地狱，提高代码的可读性和可维护性。</p>
            <p>链式调用的基本步骤包括：</p>
            <ol>
                <li>创建一个新的 Promise 对象，并调用 `resolve` 或 `reject` 来变更其状态。</li>
                <li>在 `then` 或 `catch` 方法中，处理成功或失败的状态。</li>
                <li>在 `then` 方法中，可以使用 `return` 关键字返回一个新的 Promise 对象，或者直接返回普通值。</li>
                <li>继续在下一个 `then` 方法中处理返回的 Promise 对象，或者直接处理返回的普通值。</li>
            </ol>
            <p>例如，以下代码展示了如何使用 `.then()` 和 `.catch()` 方法进行链式调用：</p>
            <pre data-index="25" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">let</span> promise1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">'new promise111111'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">});</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">promise1.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// 输出: 'new promise111111'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> <span class="hljs-string">'链式调用的方式'</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value); <span class="hljs-comment">// 输出: '链式调用的方式'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">});</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:15,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box15"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <p>在这个例子中，`promise1` 被成功地 resolve 并返回了一个值，然后 `then` 方法被调用，返回了一个新的 Promise 对象，并返回了 `'链式调用的方式'`。这个新的 Promise
                对象又被继续 `.then` 处理，最终返回了 `'链式调用的方式'`。</p>
            <p>需要注意的是，每次 `.then` 方法调用都会返回一个新的 Promise 对象，因此链式调用的结果取决于最后 `.then` 方法中返回的值或新的 Promise 对象。</p>
            <ul>
                <li><strong>错误捕获</strong></li>
            </ul>
            <p>Promise.prototype.catch用于指定Promise状态变为rejected时的回调函数，可以认为是.then的简写形势，返回值跟.then一样</p>
            <pre data-index="26" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-title function_">reject</span>(<span class="hljs-string">'error'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">});</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">obj.<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">})</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:16,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box16"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <ol>
                <li>async、await的用法</li>
            </ol>
            <p>特点简洁：<a
                    href="https://so.csdn.net/so/search?q=%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B&amp;spm=1001.2101.3001.7020"
                    title="异步编程">异步编程</a>的最高境界就是不关心它是否是异步。async、await很好的解决了这一点，将异步强行转换为同步处理。<br>
                async/await与promise不存在谁代替谁的说法，因为async/await是寄生于Promise，Generater的<a
                    href="https://so.csdn.net/so/search?q=%E8%AF%AD%E6%B3%95%E7%B3%96&amp;spm=1001.2101.3001.7020"
                    title="语法糖">语法糖</a>。</p>
            <ul>
                <li><strong>用法</strong></li>
            </ul>
            <p>async用于申明一个function是异步的，而await可以认为是async wait的简写，等待一个异步方法执行完成。<br> 规则：<br> 1
                async和await是配对使用的，await存在于async的内部。否则会报错<br> 2 await表示在这里等待一个promise返回，再接下来执行<br> 3
                await后面跟着的应该是一个promise对象，（也可以不是，如果不是接下来也没什么意义了…）</p>
            <ul>
                <li><strong>写法</strong></li>
            </ul>
            <pre data-index="27" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">let</span> a= <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">//上一个await执行之后才会执行下一句</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">let</span> b= <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(a+ <span class="hljs-number">100</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">let</span> c= <span class="hljs-keyword">await</span> <span class="hljs-title function_">sleep</span>(b+ <span class="hljs-number">100</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> c; <span class="hljs-comment">// console.log(c);</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-title function_">demo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">});</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:17,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box17"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <ul>
                <li><strong>错误捕获</strong></li>
            </ul>
            <p>如果是reject状态，可以用try-catch捕捉</p>
            <pre data-index="28" class="set-code-show"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-title function_">reject</span>(<span class="hljs-string">'error'</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    },<span class="hljs-number">1000</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">});</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">demo</span>(<span class="hljs-params">item</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">try</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> obj;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    } <span class="hljs-keyword">catch</span>(e) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-title function_">demo</span>();</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:18,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box18"><i></i>运行<div><button>运行</button></div></div></div></pre>
            <ul>
                <li><strong>两者区别</strong></li>
            </ul>
            <p>1、promise是ES6，async/await是ES7<br> 2、async/await相对于promise来讲，写法更加优雅<br> 3、reject状态：<br> &nbsp; &nbsp;
                （1）promise错误可以通过catch来捕捉，建议尾部捕获错误，<br> &nbsp; &nbsp; （2）async/await既可以用.then又可以用try-catch捕捉</p>
            <p>推荐一篇Promise文章：<a href="https://juejin.cn/post/6844904181627781128" rel="nofollow"
                    title="https://juejin.cn/post/6844904181627781128">https://juejin.cn/post/6844904181627781128</a>
            </p>
        </blockquote>
        <h5 id="23%E3%80%81JS%E4%B8%AD%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%C2%A0">
            23、JS中数组常用方法详解&nbsp;</h5>
        <div class="table-box">
            <table border="1" cellpadding="1" cellspacing="1" style="width:700px;">
                <tbody>
                    <tr>
                        <th style="width:75px;">顺序</th>
                        <th style="width:159px;">方法名</th>
                        <th>功能</th>
                        <th>返回值</th>
                        <th>是否改变原数组</th>
                        <th>版本</th>
                    </tr>
                    <tr>
                        <td style="width:75px;">1</td>
                        <td style="width:159px;">push()</td>
                        <td>(在结尾)向数组添加一或多个元素</td>
                        <td>返回新数组长度</td>
                        <td>Y</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">2</td>
                        <td style="width:159px;">unshift()</td>
                        <td>（在开头)向数组添加一或多个元素</td>
                        <td>返回新数组长度</td>
                        <td>Y</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">3</td>
                        <td style="width:159px;">pop()</td>
                        <td>删除数组的最后一位</td>
                        <td>返回被删除的数据</td>
                        <td>Y</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">4</td>
                        <td style="width:159px;">shift()</td>
                        <td>移除数组的第一项</td>
                        <td>返回被删除的数据</td>
                        <td>Y</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">5</td>
                        <td style="width:159px;">reverse()</td>
                        <td>反转数组中的元素</td>
                        <td>返回反转后数组</td>
                        <td>Y</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">6</td>
                        <td style="width:159px;">sort()</td>
                        <td>以字母顺序(字符串Unicode码点)对数组进行排序</td>
                        <td>返回新数组</td>
                        <td>Y</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">7</td>
                        <td style="width:159px;">splice()</td>
                        <td>在指定位置删除指定个数元素再增加任意个数元素 （实现数组任意位置的增删改)</td>
                        <td>返回删除的数据所组成的数组</td>
                        <td>Y</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">8</td>
                        <td style="width:159px;">concat()</td>
                        <td>通过合并（连接）现有数组来创建一个新数组</td>
                        <td>返回合并之后的数组</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">9</td>
                        <td style="width:159px;">join()</td>
                        <td>用特定的字符,将数组拼接形成字符串 (默认",")</td>
                        <td>返回拼接后的新数组</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">10</td>
                        <td style="width:159px;">slice()</td>
                        <td>裁切指定位置的数组</td>
                        <td>被裁切的元素形成的新数组</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">11</td>
                        <td style="width:159px;">toString()</td>
                        <td>将数组转换为字符串</td>
                        <td>新数组</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">12</td>
                        <td style="width:159px;">valueOf()</td>
                        <td>查询数组原始值</td>
                        <td>数组的原始值</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">13</td>
                        <td style="width:159px;">indexOf()</td>
                        <td>查询某个元素在数组中第一次出现的位置</td>
                        <td>存在该元素,返回下标,不存在 返回 -1</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">14</td>
                        <td style="width:159px;">lastIdexOf()</td>
                        <td>反向查询数组某个元素在数组中第一次出现的位置</td>
                        <td>存在该元素,返回下标,不存在 返回 -1</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">15</td>
                        <td style="width:159px;">forEach()</td>
                        <td>(迭代) 遍历数组,每次循环中执行传入的回调函数</td>
                        <td>无/(undefined)</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">16</td>
                        <td style="width:159px;">map()</td>
                        <td>(迭代) 遍历数组, 每次循环时执行传入的回调函数,根据回调函数的返回值,生成一个新的数组</td>
                        <td>有/自定义</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">17</td>
                        <td style="width:159px;">filter()</td>
                        <td>(迭代) 遍历数组, 每次循环时执行传入的回调函数,回调函数返回一个条件,把满足条件的元素筛选出来放到新数组中</td>
                        <td>满足条件的元素组成的新数组</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">18</td>
                        <td style="width:159px;">every()</td>
                        <td>(迭代) 判断数组中所有的元素是否满足某个条件</td>
                        <td>全都满足返回true 只要有一个不满足 返回false</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">19</td>
                        <td style="width:159px;">some()</td>
                        <td>(迭代) 判断数组中是否存在,满足某个条件的元素</td>
                        <td>只要有一个元素满足条件就返回true,都不满足返回false</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">20</td>
                        <td style="width:159px;">reduce()</td>
                        <td>(归并)遍历数组, 每次循环时执行传入的回调函数,回调函数会返回一个值,将该值作为初始值prev,传入到下一次函数中</td>
                        <td>最终操作的结果</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">21</td>
                        <td style="width:159px;">reduceRight()</td>
                        <td>(归并)用法同reduce,只不过是从右向左</td>
                        <td>同reduce</td>
                        <td>N</td>
                        <td>ES5-</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">22</td>
                        <td style="width:159px;">includes()</td>
                        <td>判断一个数组是否包含一个指定的值.</td>
                        <td>是返回 true，否则false</td>
                        <td>N</td>
                        <td>ES6</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">23</td>
                        <td style="width:159px;">Array.from()</td>
                        <td>接收伪数组,返回对应的真数组</td>
                        <td>对应的真数组</td>
                        <td>N</td>
                        <td>ES6</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">24</td>
                        <td style="width:159px;">find()</td>
                        <td>遍历数组,执行回调函数,回调函数执行一个条件,返回满足条件的第一个元素,不存在返回undefined</td>
                        <td>满足条件第一个元素/否则返回undefined</td>
                        <td>N</td>
                        <td>ES6</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">25</td>
                        <td style="width:159px;">findIndex()</td>
                        <td>遍历数组,执行回调函数,回调函数接受一个条件,返回满足条件的第一个元素下标,不存在返回-1</td>
                        <td>满足条件第一个元素下标,不存在=&gt;-1</td>
                        <td>N</td>
                        <td>ES6</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">26</td>
                        <td style="width:159px;">fill()</td>
                        <td>用给定值填充一个数组</td>
                        <td>新数组</td>
                        <td>Y</td>
                        <td>ES6</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">27</td>
                        <td style="width:159px;">flat()</td>
                        <td>用于将嵌套的数组“拉平”，变成一维的数组。</td>
                        <td>返回一个新数组</td>
                        <td>N</td>
                        <td>ES6</td>
                    </tr>
                    <tr>
                        <td style="width:75px;">28</td>
                        <td style="width:159px;">flatMap()</td>
                        <td>flat()和map()的组合版 , 先通过map()返回一个新数组,再将数组拉平( 只能拉平一次 )</td>
                        <td>返回新数组</td>
                        <td>N</td>
                        <td>ES6</td>
                    </tr>
                    <tr>
                        <td style="width:75px;"></td>
                        <td style="width:159px;"></td>
                        <td></td>
                        <td></td>
                        <td></td>
                        <td></td>
                    </tr>
                </tbody>
            </table>
        </div>
        <p></p>
        <p>1.push（）在数组<strong>最后一位</strong><em>添加</em>一个或多个元素,并返回新数组的长度,改变原数组.(添加多个元素用逗号隔开)</p>
        <p><strong>语法:&nbsp;</strong><strong>数组名.push(</strong><strong>数据)</strong></p>
        <p><strong>作用:&nbsp;</strong>就是往数组末尾添加数据</p>
        <p><strong>返回值:</strong>&nbsp;就是这个数组的长度</p>
        <pre data-index="29" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//push</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">res = arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">20</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30,40,20]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:19,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box19"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p>2. pop（） 末尾出删除数据</p>
        <p><strong>语法:</strong><strong>数组名.pop()</strong></p>
        <p><strong>作用:&nbsp;</strong>就是从数组的末尾删除一个数据</p>
        <p><strong>返回值:&nbsp;</strong>就是你删除的那个数据</p>
        <pre data-index="30" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//pop</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>] </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">res =arr.<span class="hljs-title function_">pop</span>()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[10,20,30]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//40</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:20,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box20"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p>3.unshift（） 头部添加数据</p>
        <p><strong>语法:&nbsp;</strong><strong>数组名.unshift(</strong><strong>数据)</strong></p>
        <p><strong>作用:</strong>&nbsp;就是在数组的头部添加数据</p>
        <p><strong>返回值:&nbsp;</strong>就是数组的长度</p>
        <pre data-index="31" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-comment">//pop</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> res=arr.<span class="hljs-title function_">unshift</span>(<span class="hljs-number">99</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[99,10,20,30,40]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//5</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:21,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box21"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p>4.shift（） 头部删除数据</p>
        <p><strong>语法:&nbsp;</strong><strong>数组名.shift()</strong></p>
        <p><strong>作用:</strong>&nbsp;头部删除一个数据</p>
        <p><strong>返回值:</strong>&nbsp;就是删除掉的那个数据</p>
        <pre data-index="32" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//shift</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> res=arr.<span class="hljs-title function_">shift</span>()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);[<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-number">10</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>5.reverse（） 翻转数组</p>
        <p><strong>语法:&nbsp;</strong><strong>数组名.reverse()</strong></p>
        <p><strong>作用:&nbsp;</strong>就是用来翻转数组的</p>
        <p><strong>返回值:&nbsp;</strong>就是翻转好的数组</p>
        <pre data-index="33" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//reverse</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">res=arr.<span class="hljs-title function_">reverse</span>()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);<span class="hljs-comment">//[40,30,20,10]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<span class="hljs-comment">//[40,30,20,10]</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:22,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box22"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p>6.sort（） 排序</p>
        <p><strong>语法一:&nbsp;</strong><strong>数组名.sort()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;&nbsp;会排序
            会按照位排序</p>
        <p><strong>语法二:&nbsp;</strong><strong>数组名.sort(function (a,b) {return a-b})</strong>&nbsp;&nbsp;会正序排列</p>
        <p><strong>语法三:&nbsp;</strong><strong>数组名.sort(function (a,b) {return b-a})</strong>&nbsp;&nbsp;会倒序排列</p>
        <pre data-index="34" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//sort()</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">63</span>, <span class="hljs-number">48</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">75</span>, <span class="hljs-number">69</span>, <span class="hljs-number">11</span>, <span class="hljs-number">23</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">arr.<span class="hljs-title function_">sort</span>()</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>){<span class="hljs-keyword">return</span>(a-b)})</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">arr.<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>){<span class="hljs-keyword">return</span>(b-a)})</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>打印结果：<img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/e4ec9468a7c63cf412c9abe4d3aabad3.png"></p>
        <p>7.splice（） &nbsp;截取数组</p>
        <p><strong>语法一:&nbsp;</strong><strong>数组名.splice(</strong><strong>开始索引,</strong><strong>多少个)</strong></p>
        <p><strong>作用:&nbsp;</strong>就是用来截取数组的</p>
        <p><strong>返回值:&nbsp;</strong>是一个新数组 里面就是你截取出来的数据</p>
        <p><strong>语法二:&nbsp;</strong><strong>数组名.splice(</strong><strong>开始索引,</strong><strong>多少个,</strong><strong>你要插入的数据)</strong>
        </p>
        <p><strong>作用:</strong>&nbsp;删除并插入数据</p>
        <p><strong>注意:</strong>&nbsp;从你的开始索引起</p>
        <p><strong>返回值:&nbsp;</strong>是一个新数组 里面就是你截取出来的数据</p>
        <pre data-index="35" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//splice() 语法一</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">63</span>, <span class="hljs-number">48</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">75</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">res = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr);  <span class="hljs-comment">// [2, 5, 4, 75]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);  <span class="hljs-comment">// [63, 48]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//******************************</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//splice() 语法二</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">63</span>, <span class="hljs-number">48</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">75</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">res = arr.<span class="hljs-title function_">splice</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">99999</span>,<span class="hljs-number">88888</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr); <span class="hljs-comment">//[2, 99999, 88888, 48, 5, 4, 75]</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <span class="hljs-comment">// [63]</span></div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:23,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box23"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p><strong>二、不改变原数组的方法</strong></p>
        <p>1.concat（） &nbsp;合并数组</p>
        <p>功能： 数组的拼接(将多个数组或元素拼接形成一个新的数组),不改变原数组<br> 如果拼接的是数组 则将数组展开,之后将数组中的每一个元素放到新数组中.<br> 如果是其他类型, 直接放到新数组中<br>
            另外，如果不给该方法任何参数，将返回一个和原数组一样的数组（复制数组）</p>
        <pre data-index="36" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> arr2 = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> arr3 = [<span class="hljs-string">"A"</span>, <span class="hljs-string">"B"</span>, <span class="hljs-string">"C"</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> rel = arr1.<span class="hljs-title function_">concat</span>(arr2, arr3);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr1); <span class="hljs-comment">//原数组</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rel); <span class="hljs-comment">//新数组</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>打印结果：<img alt="" src="https://i-blog.csdnimg.cn/blog_migrate/eb89207b4227c3c92c8d0215e1c86dcb.png">&nbsp;</p>
        <p>2.join（） 数组转字符串 语法:数组名.join('连接符') 作用: 就是把一个数组转成字符串</p>
        <p>功能：用特定的字符,将数组拼接形成字符串 (默认",")</p>
        <pre data-index="37" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-keyword">var</span> list = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>]; <span class="hljs-comment">// "a-b-c-d"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> result = list.<span class="hljs-title function_">join</span>(<span class="hljs-string">"-"</span>);     <span class="hljs-comment">//"a-b-c-d"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> result = list.<span class="hljs-title function_">join</span>(<span class="hljs-string">"/"</span>);     <span class="hljs-comment">//"a/b/c/d"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> result = list.<span class="hljs-title function_">join</span>(<span class="hljs-string">""</span>);      <span class="hljs-comment">//"abcd"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">var</span> result = list.<span class="hljs-title function_">join</span>();        <span class="hljs-comment">//  a,b,c,d</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:24,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box24"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p><span style="color:#be191c;"><span
                    style="background-color:#fef2f0;">find()返回匹配的元素，findIndex()返回匹配元素的索引，find()如果没有匹配到元素则返回undefined,
                    而findIndex()返回-1</span></span></p>
        <p><strong>1、数组方法find()</strong></p>
        <ul>
            <li>返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</li>
            <li>find方法对数组中的每一项元素执行一次 callback 函数，直至有一个 callback 返回 true。当找到了这样一个元素后，该方法会立即返回这个元素的值，否则返回 undefined。</li>
            <li>注意 callback 函数会为数组中的每个索引调用即从 0 到 length - 1，而不仅仅是那些被赋值的索引，这意味着对于稀疏数组来说，该方法的效率要低于那些只遍历有值的索引的方法。</li>
            <li>callback函数带有3个参数：<strong>当前元素的值、当前元素的索引，以及数组本身</strong>。</li>
            <li>如果提供了 thisArg参数，那么它将作为每次 callback函数执行时的this ，如果未提供，则使用 undefined。</li>
            <li>find方法不会改变数组。</li>
        </ul>
        <p>实战举例：</p>
        <pre data-index="38" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    {<span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>},</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    {<span class="hljs-attr">name</span>: <span class="hljs-string">'李四'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>},</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arrTest = arr.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前值:'</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(item), <span class="hljs-string">'当前值的索引：'</span> + index, <span class="hljs-string">'当前数组：'</span> + array)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> item.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">})</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrTest)</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:25,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box25"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p>打印结果：</p>
        <pre data-index="39" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">当前值:{<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>,<span class="hljs-string">"age"</span>:<span class="hljs-number">18</span>} 当前值的索引：<span class="hljs-number">0</span> 当前数组：[object <span class="hljs-title class_">Object</span>],[object <span class="hljs-title class_">Object</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">{<span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>}</div></div></li></ol></code><div class="hljs-button {2} def" data-title="复制" onclick="hljs.copyCode(event)" data-report-click="{&quot;spm&quot;:&quot;3001.10243&quot;}"></div>'<div class="code-edithtml  " data-title="运行"><div data-report-click="{&quot;spm&quot;:&quot;3001.10182&quot;,&quot;extra&quot;:{&quot;index&quot;:26,&quot;ab&quot;:&quot;exp1&quot;}}" class="code-edithtml-box code-edithtml-box26"><i></i>运行<div><button>运行</button></div></div></div></pre>
        <p><strong>2、数组方法<code>findIndex()</code></strong></p>
        <ul>
            <li><code>返回数组中满足提供的测试函数的第一个元素的索引。否则返回-1。 </code></li>
            <li><code>findIndex方法对数组中的每个数组索引0..length-1（包括）执行一次callback函数，直到找到一个callback函数返回真实值（强制为true）的值。 </code></li>
            <li><code>如果找到这样的元素，findIndex会立即返回该元素的索引。 </code></li>
            <li><code>如果回调从不返回真值，或者数组的length为0，则findIndex返回-1。 </code></li>
            <li><code>与某些其他数组方法（如Array#some）不同，在稀疏数组中，即使对于数组中不存在的条目的索引也会调用回调函数。 </code></li>
            <li><code>回调函数调用时有三个参数：元素的值，元素的索引，以及被遍历的数组。 </code></li>
            <li><code>如果一个 thisArg 参数被提供给 findIndex, 它将会被当作this使用在每次回调函数被调用的时候。如果没有被提供，将会使用 undefined。findIndex不会修改所调用的数组。</code>
            </li>
        </ul>
        <p>实战举例：</p>
        <pre data-index="40" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:861px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            {<span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>},</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            {<span class="hljs-attr">name</span>: <span class="hljs-string">'王二'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span>},</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">        ]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arrTest = arr.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function">(<span class="hljs-params">item, index, array</span>) =&gt;</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'当前值:'</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(item), <span class="hljs-string">'当前值的索引：'</span> + index, <span class="hljs-string">'当前数组：'</span> + array)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">            <span class="hljs-keyword">return</span> item.<span class="hljs-property">name</span> === <span class="hljs-string">'张三'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">})</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arrTest)</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>打印结果：&nbsp;</p>
        <pre data-index="41" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">当前值:{<span class="hljs-string">"name"</span>:<span class="hljs-string">"张三"</span>,<span class="hljs-string">"age"</span>:<span class="hljs-number">18</span>} 当前值的索引：<span class="hljs-number">0</span> 当前数组：[object <span class="hljs-title class_">Object</span>],[object <span class="hljs-title class_">Object</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-number">0</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>3、JSON.stringify( ) 和&nbsp;JSON.parse( )</p>
        <p><strong>JSON.stringify()</strong>：将对象、<a
                href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020"
                title="数组转换成字符串">数组转换成字符串</a><br><strong>JSON.parse()</strong>：将字符串转成<a
                href="https://so.csdn.net/so/search?q=json%E5%AF%B9%E8%B1%A1&amp;spm=1001.2101.3001.7020"
                title="json对象">json对象</a></p>
        <p>JSON.parse(JSON.stringify(obj))我们一般用来深拷贝，其过程说白了 就是利用JSON.stringify
            将js对象序列化（JSON字符串），再使用JSON.parse来反序列化(还原)js对象；序列化的作用是存储(对象本身存储的只是一个地址映射，如果断电，对象将不复存在，因此需将对象的内容转换成字符串的形式再保存在磁盘上
            )</p>
        <p><strong>应用场景</strong><br> a、浏览器创建、获取（sessionStorage、localStorage）数组内容<br> b、路由（浏览器地址）传参、获取数组内容<br>
            创建、传参的时候使用<strong>JSON.stringify()深拷贝</strong><br> (如果不使用JSON.stringify()存进去的将是[object
            object]，所以如果我们开发中遇到了获取内容的时候是[object object]不妨试试JSON.stringify())</p>
        <p>4、instanceof( )</p>
        <p><code>instanceof</code><a
                href="https://so.csdn.net/so/search?q=%E8%BF%90%E7%AE%97%E7%AC%A6&amp;spm=1001.2101.3001.7020"
                title="运算符">运算符</a>返回一个布尔值，如下：</p>
        <pre data-index="42" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> obj = {};</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( array <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span> ) <span class="hljs-comment">// true</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( obj  <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>)  <span class="hljs-comment">// true</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>5、<strong>every()方法的定义与用法：</strong></p>
        <ul>
            <li>every()方法用于检测数组中的所有元素是否都满足指定条件（该条件为一个函数）。</li>
            <li>every()方法会遍历数组的每一项，如果有有一项不满足条件，则表达式返回false,剩余的项将不会再执行检测；如果遍历完数组后，每一项都符合条，则返回true。</li>
        </ul>
        <p><strong>标准用法：</strong></p>
        <pre data-index="43" class="set-code-show" name="code"><code class="language-javascript hljs">array.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">currentValue,index,arr</span>), thisValue)
</code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p><strong>参数说明：</strong></p>
        <ul>
            <li>第一个参数为一个回调函数，必传，数组中的每一项都会遍历执行该函数。</li>
        </ul>
        <p>&nbsp; &nbsp; currentValue：必传，当前项的值<br> &nbsp; &nbsp; index：选传，当前项的索引值<br> &nbsp; &nbsp; arr：选传，当前项所属的数组对象
        </p>
        <ul>
            <li>第二个参数thisValue为可选参数，回调函数中的this会指向该参数对象。</li>
        </ul>
        <p><strong>Tips:</strong></p>
        <ul>
            <li>every() 不会对空数组进行检测</li>
            <li>every() 不会改变原始数组</li>
        </ul>
        <p><strong>代码实例：</strong></p>
        <pre data-index="44" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1000</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">3000</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> flag = arr.<span class="hljs-title function_">every</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c</span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a + <span class="hljs-string">"==="</span> + b + <span class="hljs-string">"===="</span> + c) <span class="hljs-comment">//1000===0====1000,2000,3000</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> a &gt; <span class="hljs-number">2000</span>;<span class="hljs-comment">//数组中的每个元素的值都要大于2000的情况,最后才返回true</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">})</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(flag)   <span class="hljs-comment">//false</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>6、<strong>数组some方法作用</strong></p>
        <p>判断数组中是否有满足条件的元素</p>
        <p>语法：<strong>array.some( function ( item, index, arr) {} ,thisValue)</strong><br> function ：必须,数组中的每个元素都会执行这个函数
        </p>
        <ul>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; 第一个参数:item,必须,当前元素的值</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; 第二个参数:index,可选,当前元素在数组中的索引值</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; 第三个参数:arr,当前元素属于的数组对象</li>
        </ul>
        <p>thisValue ：可选，对象作为该执行回调时使用，传递给函数，用作 "this" 的值。<br> 如果省略了 thisValue ，"this" 的值为 "undefined"</p>
        <p><strong>some方法特点</strong><br> (1)函数执行次数 !== 数组长度</p>
        <p>(2)函数内部的return</p>
        <p>&nbsp; &nbsp; &nbsp; &nbsp; return true : 循环结束,找到了满足条件的元素</p>
        <p>&nbsp; &nbsp; &nbsp; &nbsp; return false : 循环继续,没找到循环继续,如果所有元素全部遍历还是没找到,最终结果为false<br> (3) some()方法不会对空数组进行检测
        </p>
        <p>(4) some()方法不会改变原始数组</p>
        <p>应用场景 :
            这个方法与every()方法极为相似，但又有所不同，every要求每一项都要符合函数里面的条件，<strong>而some只要求有数组中的某一项符合即可</strong>，这点类似于或与和。返回的是布尔值，使用事例如下：
        </p>
        <pre data-index="45" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span>  num = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">var</span> eve = num.<span class="hljs-title function_">some</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">item, index, arr</span>){</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> (item &gt; <span class="hljs-number">2</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">});</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eve);  <span class="hljs-comment">//true</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>7、数组filter()方法</p>
        <p>filter()方法的回调函数接受三个参数：当前元素、当前元素的索引和数组本身。其中，当前元素是必需的，而索引和数组是可选的。过滤数组中，符合条件的元素并返回一个新的数组</p>
        <pre data-index="46" class="set-code-show"
            name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:905px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> people = [</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Alice'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">25</span> },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Bob'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">17</span> },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Charlie'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  { <span class="hljs-attr">name</span>: <span class="hljs-string">'David'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">16</span> },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  { <span class="hljs-attr">name</span>: <span class="hljs-string">'Eva'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">18</span> }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">];</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">const</span> adults = people.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">person</span> =&gt;</span> person.<span class="hljs-property">age</span> &gt;= <span class="hljs-number">18</span>);</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(adults); <span class="hljs-comment">// [{ name: 'Alice', age: 25 }, { name: 'Charlie', age: 30 }, { name: 'Eva', age: 18 }]</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <p>8、</p>
        <p></p>
        <p></p>
        <p></p>
        <h4 id="%E4%BA%94%E3%80%81Vue%E7%AF%87"><a name="t11"></a><span
                style="color:#0d0016;"><strong>五、</strong>Vue2篇</span></h4>
        <h5
            id="%F0%9F%8D%877%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%3F%E6%AF%94%E5%A6%82%EF%BC%88Vue2%E7%9A%84webpack%EF%BC%8CVue3%E7%9A%84Vite%EF%BC%89">
            <strong>&ZeroWidthSpace;</strong>1、什么是前端构建工具?比如（Vue2的webpack，Vue3的Vite）</h5>
        <blockquote>
            <p><span style="color:#fe2c24;">①首先要明白：浏览器它只认识html, css, js</span><br> 企业级项目里都可能会具备哪些功能？<br>
                1.&nbsp;typescript:·如果遇到ts文件我们需要使用tsc将typescript代码转换为js代码<br> 2.&nbsp;React/<span
                    class="words-blog hl-git-1" data-tit="Vue"
                    data-pretit="vue">Vue</span>:安装react-compiler&nbsp;/&nbsp;vue-complier，将我们写的jsx文件或者.vue文件转换为render函数<br>
                3.&nbsp;less/postcss/component-style:我们又需要安装less-loader,&nbsp;sass-loader等一系列编译工具4.&nbsp;语法降级:babel&nbsp;---&gt;将es的新语法转换旧版浏览器可以接受的语法<br>
                5.&nbsp;体积优化:uglifyjs&nbsp;---&gt;将我们的代码进行压缩变成体积更小性能更高的文件<br><span
                    style="color:#fe2c24;">②前因后果：</span><br> 因为稍微改一点点东西，非常麻烦！<br> 将App.tsx ---&gt;tsc ---&gt;· App.jsx
                ---&gt;React-complier ---&gt;js文件<br> 但是有一个东西能够帮你把tsc,react-compiler, less,
                babel,uglifyjs全部集成到一起，我们只需要关心我们写的代码就好了<br> 我们写的代码变化--&gt;有人帮我们自动去tsc, react-compiler,less, babel,
                uglifyjs全部挨个走一遍--&gt;js<br> 这个东西就叫做 <span style="color:#1c7331;">前端构建工具</span><br><span
                    style="color:#fe2c24;">③前端构建工具的工作：</span><br> 打包:
                将我们写的浏览器不认识的代码交给构建工具进行编译处理的过程就叫做打包，打包完成以后会给我们一个浏览器可以认识的文件。<br> 一个构建工具他到底承担了哪些脏活累活:<br>
                1.模块化开发支持：支持直接从node_modules里引入代码＋多种模块化支持<br> 2.处理代码兼容性：比始babel语法降级，less,ts
                语法转换(**不是构建工具做的，构建工具将这些语法对应的处理工具集成进来自动化处理)<br> 3.提高项目性能：压缩文件，**代码分割*<br> 4.优化开发体验:<br>
                （1）构建工具会帮你自动监听文件的变化，当文件变化以后自动帮你调用对应的集成工具进行重新打包，然后再浏览器重新运行（整个过程叫做热更新, hot replacement）<br>
                （2）开发服务器:跨域的问题，用react-cli create-react-element-vue-cli·解决跨域的问题,<br><span
                    style="color:#fe2c24;">④构建工具总结：&nbsp;</span><br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;构建工具它让我们可以不用每次都关心我们的代码在浏览器如何运行，我们只需要首次给构建工具提供一个配置文件(这个配置文件也不是必须的，如果你不给他他会有默认的帮你去处理)，有了这个集成的配置文件以后，我们就可以在下次需要更新的时候调用一次对应的命令就好了，如果我们再结合热更新，我们就更加不需要管任何东西，这就是构建工具去做的东西。<br><span
                    style="color:#1c7331;">构建工具它让我们不用关心生产的代码，也不用去关心代码如何在浏览器运行，只需要关心我们的开发怎么写的爽怎么写就好了</span></p>
        </blockquote>
        <h5
            id="%F0%9F%8D%8710%E3%80%81Vue%20%E7%BB%84%E4%BB%B6%E9%97%B4%E9%80%9A%E4%BF%A1%E5%85%AD%E7%A7%8D%E6%96%B9%E5%BC%8F">
            <strong>&ZeroWidthSpace;</strong>2、Vue 组件之间的通信方式</h5>
        <blockquote>
            <p id="1.%E7%88%B6%E7%BB%84%E4%BB%B6%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC">
                <strong>（1）父组件向子组件传值</strong></p>
            <div>
                <pre data-index="47" class="set-code-show"
                    name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//App.vue父组件</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">users</span> <span class="hljs-attr">:users</span>=<span class="hljs-string">"users"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">users</span>&gt;</span>//前者自定义名称便于子组件调用，后者要传递数据名</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;script&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Chilren</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/chilren "</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">name</span>: <span class="hljs-string">'App'</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>){</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">users</span>:[<span class="hljs-string">"HelloKK"</span>]</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">components</span>:{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-title class_">Chilren</span>:<span class="hljs-title class_">Chilren</span> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            </div>
            <div>
                <pre data-index="48" class="set-code-show"
                    name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">//chilren子组件</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"hello"</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"user in users"</span>&gt;</span>{{user}}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>//遍历传递过来的值，然后呈现到页面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">name</span>: <span class="hljs-string">'chilren'</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">props</span>:{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-attr">users</span>:{           <span class="hljs-comment">//这个就是父组件中子标签自定义名字</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">type</span>:<span class="hljs-title class_">Array</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">required</span>:<span class="hljs-literal">true</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            </div>
            <p
                id="2.%E5%AD%90%E7%BB%84%E4%BB%B6%E5%90%91%E7%88%B6%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%80%BC%EF%BC%88%E9%80%9A%E8%BF%87%E4%BA%8B%E4%BB%B6%E5%BD%A2%E5%BC%8F%EF%BC%89">
                <strong>（2）子组件向父组件传值</strong></p>
            <div>
                <pre data-index="49" class="set-code-show"
                    name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 子组件</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"changeTitle"</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>//绑定一个点击事件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">name</span>: <span class="hljs-string">'app-header'</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">title</span>:<span class="hljs-string">"Vue.js Demo"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">methods</span>:{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-title function_">changeTitle</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">"titleChanged"</span>,<span class="hljs-string">"子向父组件传值"</span>);<span class="hljs-comment">//自定义事件  传递值“子向父组件传值”</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            </div>
            <div>
                <pre data-index="50" class="set-code-show"
                    name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-comment">// 父组件</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">app-header</span> <span class="hljs-attr">v-on:titleChanged</span>=<span class="hljs-string">"updateTitle"</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">app-header</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    //与子组件titleChanged自定义事件保持一致</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   // updateTitle($event)接受传递过来的文字</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>{{title}}<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Header</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"./components/Header"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">name</span>: <span class="hljs-string">'App'</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>){</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span>{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">title</span>:<span class="hljs-string">"传递的是一个值"</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">methods</span>:{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-title function_">updateTitle</span>(<span class="hljs-params">e</span>){   <span class="hljs-comment">//声明这个函数</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = e;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">components</span>:{</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="25"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">   <span class="hljs-string">"app-header"</span>:<span class="hljs-title class_">Header</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="26"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="27"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="28"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            </div>
        </blockquote>
        <h5 id="%F0%9F%8D%8711%E3%80%81Vuex%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">
            <strong>&ZeroWidthSpace;</strong>3、Vuex的理解及使用场景</h5>
        <blockquote>
            <p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。</p>
            <p>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新 2. 改变 store 中的状态的唯一途径就是显式地提交
                (commit) mutation， 这样使得我们可以方便地跟踪每一个状态的变化 Vuex主要包括以下几个核心模块：</p>
            <p><strong>1.State：</strong>定义了应用的状态数据</p>
            <p><strong>2.Getter：</strong>在 store 中定义“getter”（可以认为是 store 的计算属性），</p>
            <p>就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来， 且只有当它的依赖值发生了改变才会被重新计算</p>
            <p><strong>3. Mutation：</strong>是唯一更改 store 中状态的方法，且必须是同步函数</p>
            <p><strong>4. Action：</strong>用于提交 mutation，而不是直接变更状态，可以包含任意异步操作</p>
            <p><strong>5. Module：</strong>允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中</p>
            <p><img alt="" height="479"
                    src="https://i-blog.csdnimg.cn/blog_migrate/41c6bb54707db59a63549092b992b5c2.png"
                    width="748">&ZeroWidthSpace;</p>
            <p></p>
        </blockquote>
        <h5
            id="%C2%A0%E2%80%8B%E7%BC%96%E8%BE%914%E3%80%81vue%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%C2%A0%E5%85%AB%E4%B8%AA%E9%98%B6%E6%AE%B5">
            4、vue 的生命周期&nbsp;八个阶段</h5>
        <blockquote>
            <p><strong><strong>1.beforeCreate</strong></strong></p>
            <p><span style="color:#1c7331;">在实例创建之间执行，数据是未加载状态。</span></p>
            <p>创建一个Vue实例，此时实例上只有一些生命周期函数和默认的事件</p>
            <p>此时data computed watch methods上的方法和数据均不能访问</p>
            <p><strong><strong>2.created</strong></strong></p>
            <p><span style="color:#1c7331;">在实例创建、数据加载后，能初始化数据，DOM渲染之前执行。</span></p>
            <p>可以对data数据进行操作，可进行一些请求，请求不易过多，避免白屏时间太长。</p>
            <p><strong><strong>3.beforeMount</strong></strong></p>
            <p><span style="color:#1c7331;">虚拟DOM已创建完成，在数据渲染前最后一次更改数据。el未挂载。</span></p>
            <p>判断el的挂载方式</p>
            <p>判断是否有template设置</p>
            <p>将template进行渲染保存到内存当中，还未挂载在页面上</p>
            <p><strong><strong>4.mounted</strong></strong></p>
            <p><span style="color:#1c7331;">页面、数据渲染完成。el挂载完毕。可以访问DOM节点。</span></p>
            <p>将内存中的模版挂载到页面上</p>
            <p>此时可以操作页面上的DOM节点</p>
            <p>此时组件从创建阶段进入运行阶段</p>
            <p><strong><strong>5.beforeUpdate</strong></strong></p>
            <p><span style="color:#1c7331;">重新渲染之前触发。不会造成重渲染。</span></p>
            <p>页面显示的数据是旧的，此时data里面的数据是最新，页面数据和data数据暂未同步<strong>6.updated</strong></p>
            <p><span style="color:#1c7331;">数据已经更新完成，DOM也重新render完成，更改数据会陷入死循环。</span></p>
            <p>根据data里的最新数据渲染出最新的DOM树，然后将最新的DOM挂载到页面</p>
            <p>此时data和页面数据一致，都是最新的</p>
            <p><strong><strong>7.beforeDestroy</strong></strong></p>
            <p><span style="color:#1c7331;">实例销毁前执行，实例仍然完全可用。</span></p>
            <p>此时组件从运行阶段进入到销毁阶段</p>
            <p>组件上的data和methods以及过滤器等都出于可用状态，销毁还未执行</p>
            <p><strong><strong>8.Destroyed</strong></strong><strong>&nbsp;</strong></p>
            <p><span style="color:#1c7331;">实例销毁后执行，这时候只剩下DOM空壳。</span></p>
            <p>组件已经被完全销毁，组件中所有的数据、方法、指令、过滤器等，都已不可用</p>
        </blockquote>
        <h5
            id="5%E3%80%81%E7%AE%80%E8%BF%B0Vue%E6%AF%8F%E4%B8%AA%E5%91%A8%E6%9C%9F%E5%85%B7%E4%BD%93%E9%80%82%E5%90%88%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%EF%BC%9F">
            <strong>5、简述Vue</strong>每个周期具体适合哪些场景<strong>？</strong></h5>
        <blockquote>
            <ol>
                <li><strong>beforeCreate</strong>：
                    在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法
                </li>
                <li><strong>created</strong>： data 和 methods都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作
                </li>
                <li><strong>beforeMount</strong>： 执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的</li>
                <li><strong>mounted</strong>：
                    执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行</li>
                <li><strong>beforeUpdate</strong>： 当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步</li>
                <li><strong>updated</strong>： 页面显示的数据和data中的数据已经保持同步了，都是最新的</li>
                <li><strong>beforeDestory</strong>： Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器
                    ……都是处于可用状态。还没有真正被销毁</li>
                <li><strong>destroyed</strong>： 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。</li>
            </ol>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%915%E3%80%81%E7%AE%80%E8%BF%B0MVVM">6、<strong>简述MVVM 和MVC的原理以及区别？</strong></h5>
        <blockquote>
            <p>MVVM视图模型双向绑定，是Model-View-ViewModel的缩写</p>
            <p>1、MVVM的优点：</p>
            <ol>
                <li>低耦合。视图（View）可以独立于Model变化和修改，一个Model可以绑定到不同的View上，当View变化的时候Model可以不变化，当Model变化的时候View也可以不变；</li>
                <li>可重用性。你可以把一些视图逻辑放在一个Model里面，让很多View重用这段视图逻辑。</li>
                <li>独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计。</li>
                <li>可测试。</li>
            </ol>
            <p><img alt="" height="654"
                    src="https://i-blog.csdnimg.cn/blog_migrate/e43d791528253b7fb44a8fcfe3fa187b.png" width="1200"></p>
            <p><img alt="" height="642"
                    src="https://i-blog.csdnimg.cn/blog_migrate/b6459086ef501118acca6692d06239af.png" width="1198"></p>
            <p>2、什么是MVC?</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVC是应用最广泛的软件架构之一,一般MVC分为:Model(模型),View(视图),Controller(控制器)。
                这主要是基于分层的目的,让彼此的职责分开.View一般用过Controller来和Model进行联系。Controller是Model和View的协调者,View和Model不直接联系。基本都是单向联系。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。
            </p>
            <p><img alt="" height="334"
                    src="https://i-blog.csdnimg.cn/blog_migrate/1423f84151e518cdd4dd13d85e7fe32c.png" width="649"></p>
            <p>Model（模型）表示应用程序核心（如数据库）。</p>
            <p>View（视图）显示效果（HTML页面）。</p>
            <p>Controller（控制器）处理输入（业务逻辑）。</p>
            <p>MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。</p>
            <p>Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。（通常模型对象负责在数据库中存取数据)</p>
            <p>View（视图）是应用程序中处理数据显示的部分。(通常视图是依据模型数据创建的)</p>
            <p>Controller（控制器）是应用程序中处理用户交互的部分。(通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据）</p>
            <p><span style="color:#0d0016;"><strong>优点:</strong></span></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">1、低耦合</span></span></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">2、重用性高</span></span></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">3、生命周期成本低</span></span></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">4、部署快</span></span></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">5、可维护性高</span></span></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">6、有利软件工程化管理</span></span><br>
                3、MVC与MVVM的区别？</p>
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MVC和MVVM的区别并不是VM完全取代了C，ViewModel存在目的在于抽离Controller中展示的业务逻辑，而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。也就是说MVVM实现的是业务逻辑组件的重用。
            </p>
            <ul>
                <li>MVC中Controller演变成MVVM中的ViewModel</li>
                <li>MVVM通过数据来显示视图层而不是节点操作</li>
                <li>MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验</li>
            </ul>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%916%E3%80%81vue%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4">7、vue常见指令</h5>
        <blockquote>
            <ul>
                <li>v-model 多用于表单元素实现双向数据绑定</li>
                <li><span style="color:#be191c;"><strong><span
                                style="background-color:#fef2f0;">v-bind：简写为冒号：“：”，动态绑定一些元素的属性，类型可以是：字符串、对象或数组。</span></strong></span>
                </li>
                <li><span style="color:#be191c;"><strong><span style="background-color:#fef2f0;">v-on:click
                                给标签绑定函数，可以缩写为：“@”，例如绑定一个点击函数 函数必须写在methods里面</span></strong></span></li>
                <li>v-for 格式： v-for="字段名 in(of) 数组json" 循环数组或json，记得加上key</li>
                <li>v-show 显示内容</li>
                <li>v-if 指令：取值为true/false，控制元素是否需要被渲染</li>
                <li>v-else 指令：和v-if指令搭配使用，没有对应的值。当v-if的值false，v-else才会被渲染出来</li>
                <li>v-else-if 必须和v-if连用</li>
                <li>v-text 解析文本</li>
                <li><strong>v-html 解析html标签 （一般常见的解决后台的富文本内容）</strong></li>
                <li><span style="color:#be191c;"><span style="background-color:#fef2f0;">v-bind:class 三种绑定方法
                        </span></span></li>
            </ul>
            <ol>
                <li><span style="color:#be191c;"><span style="background-color:#fef2f0;">对象型 "{red：isred}"</span></span>
                </li>
                <li><span style="color:#be191c;"><span style="background-color:#fef2f0;">三元型 "
                            isred？"red"："blue"</span></span></li>
                <li><span style="color:#be191c;"><span style="background-color:#fef2f0;">数组型 " [{red："isred"
                            }，{blue："isblue"}] "</span></span></li>
            </ol>
            <ul>
                <li>v-once 进入页面时 只渲染一次 不在进行渲染</li>
                <li>v-cloak 防止闪烁</li>
                <li>v-pre 把标签内部的元素原位输出</li>
            </ul>
        </blockquote>
        <h5
            id="%E2%80%8B%E7%BC%96%E8%BE%917%E3%80%81vue%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F%E8%B5%B7%E5%88%B0%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F%C2%A0">
            8、vue中的data为什么是一个函数？起到什么作用？&nbsp;</h5>
        <blockquote>
            <ul>
                <li><strong>在Vue组件中，data选项必须是一个函数，而不能直接是一个对象。这是因为Vue组件可以同时存在多个实例，如果直接使用对象形式的data选项，那么所有的实例将会共享同一个data对象，这样就会造成数据互相干扰的问题。</strong>
                </li>
                <li>因此，将data选项设置为函数可以让每个实例都拥有自己独立的data对象。当组件被创建多次时，每个实例都会调用该函数并返回一个新的data对象，从而保证了数据的隔离性。</li>
                <li>另外，data选项作为一个函数还具有一个重要的特性，就是它可以接收一个参数，这个参数是组件实例本身。这个特性在一些场景下非常有用，例如在定义组件时需要使用组件实例的一些属性或方法来计算初始数据。
                </li>
                <li>因此，为了避免数据共享和保证数据隔离性，以及方便使用组件实例的属性和方法，Vue组件中的data选项必须是一个函数。</li>
            </ul>
            <p>以下是一个简单的Vue组件示例，其中data被定义为一个函数：</p>
            <pre data-index="51" class="set-code-hide"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{{ message }}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"increment"</span>&gt;</span>{{ count }}<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-keyword">return</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">message</span>: <span class="hljs-string">'Hello, Vue!'</span>,</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">methods</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>++</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p>在这个例子中，data函数返回一个包含message和count两个属性的对象。每次创建组件实例时，Vue都会调用该函数返回一个新的数据对象，确保每个组件实例都有它自己的数据对象。</p>
        </blockquote>
        <h5 id="%E2%80%8B%E7%BC%96%E8%BE%918%E3%80%81vue%E4%B8%ADref%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9F%C2%A0%C2%A0">
            <strong>9、vue中ref的作用？&nbsp;&nbsp;</strong></h5>
        <blockquote>
            <p>1、<strong>获取DOM元素的引用</strong>。</p>
            <p>ref 加在普通的元素上，用this.ref.name 获取到的是dom元素</p>
            <p>vue给我们提供一个操作dom的属性，ref绑定在dom元素上时，用起来与id差不多，通过this.$refs来调用</p>
            <pre data-index="52" class="set-code-hide"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"testDom"</span>&gt;</span>11111<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"getTest"</span>&gt;</span>获取test节点<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">methods</span>: {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-title function_">getTest</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">testDom</span>)</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">};</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p><img alt="" height="306"
                    src="https://i-blog.csdnimg.cn/blog_migrate/d3fce7d4c8cb548a86933deb66984f95.png" width="610"></p>
            <p>2、<strong>获取子组件的引用</strong>。</p>
            <ul>
                <li>在Vue组件中使用ref可以获取子组件的引用，从而可以在父组件内部调用子组件的方法或访问其数据。</li>
                <li>在父组件中将子组件引入，并在子组件标签上添加ref属性，然后就可以通过this.$refs.myChild获取子组件的引用，在父组件内部调用子组件的sayHello方法。</li>
            </ul>
            <pre data-index="53" class="set-code-hide"
                name="code"><code class="language-javascript hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myChild"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">&lt;/template&gt;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child</span> <span class="hljs-keyword">from</span> <span class="hljs-string">'./Child.vue'</span>;</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-attr">components</span>: { <span class="hljs-title class_">Child</span> },</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-comment">// 使用this.$refs获取子组件的引用</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">myChild</span>.<span class="hljs-title function_">sayHello</span>();</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line"> </div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p>3、利用 v-for 和 ref 获取一组数组或者dom 节点</p>
            <p><img alt="" height="393"
                    src="https://i-blog.csdnimg.cn/blog_migrate/93251aa254ad153720bdd2a3b6fd0b2e.png" width="686"></p>
            <p id="%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span style="color:#fe2c24;">注意事项：</span></p>
            <ul>
                <li>
                    <p><code>ref</code> 需要在<code>dom</code>渲染完成后应用，在使用时确保<code>dom</code>已经渲染完成。比如在生命周期
                        <code>mounted(){}</code> 钩子中调用，或者在 <code>this.$nextTick(()=&gt;{})</code> 中调用。</p>
                </li>
                <li>
                    <p>如果<code>ref</code> 是循环出来的，有多个重名，那么<code>ref</code>值会是一个数组 ，此时要拿到单个<code>ref</code> 只需要循环就可以。</p>
                </li>
            </ul>
        </blockquote>
        <h5 id="10%E3%80%81vue%E4%B8%ADhash%E5%92%8Chistory%E7%9A%84%E5%8C%BA%E5%88%AB%C2%A0%EF%BC%9F%C2%A0%C2%A0">
            <strong>10、</strong>vue中hash和history的区别&nbsp;？&nbsp;&nbsp;</h5>
        <blockquote>
            <p>Vue-router的路由分为hash和history模式</p>
            <p><strong>1、hash方式</strong></p>
            <ul>
                <li>hash方式是指url中存在 # 的一种方式，是vueRouter的默认模式，</li>
                <li>当#后面的url地址发生变化时，浏览器不会向服务器发送请求，故不会刷新页面</li>
                <li>当#后面的url地址发生变化时，会触发hashChange（hash模式得核心实现原理）事件，从而，我们可以通过监听hashChange事件来知道路由发生变化，从而进一步去更新我们的页面</li>
                <li>只可修改hash部分，</li>
                <li>当浏览器刷新时，浏览器只会向服务器去请求# 前面的域名服务器下根目录下的index.html文件</li>
                <li>hash模式会创建hashHistory对象,hashHistory对象有两个方法，push() 和 replace()</li>
                <li>HashHistory.push()会将新的路由添加到浏览器访问的历史的栈顶,而HasHistory.replace()会替换到当前栈顶的路由</li>
            </ul>
            <p><strong>2、history模式</strong></p>
            <ul>
                <li>history模式得路由和域名之间直接通过/连接，无#符分隔，就是普通url形式</li>
                <li>history模式当发生路由跳转时，通过HTML5的history.pushState()方法或者history.replaceState()
                    方法改变地址栏地址，并将地址的改变记录到浏览器访问栈中。（这里有一点需要注意，它只改变了浏览器地址栏中的地址，但并不会像服务器去发送请求）</li>
                <li>当浏览器前进，后台，或者调用back(),forward(), go()等方法时，会触发popstate事件。故，我们可以通过监听popstate事件来获取最新的路由地址，从而更新页面</li>
                <li>通过pushstate() 修改的url可以是与当前url同源的任意url。</li>
                <li>需要和服务器配合使用，否则容易出现页面404的情况</li>
            </ul>
            <p><strong>总结如下：</strong></p>
            <ol>
                <li>hash模式带#号比较丑，history模式比较优雅；</li>
                <li>pushState设置的新的URL可以是与当前URL同源的任意URL；而hash只可修改#后面的部分，故只可设置与当前同文档的URL；</li>
                <li>pushState设置的新URL可以与当前URL一模一样，这样也会把记录添加到栈中；而hash设置的新值必须与原来不一样才会触发记录添加到栈中；</li>
                <li>pushState通过stateObject可以添加任意类型的数据到记录中；而hash只可添加短字符串；</li>
                <li>pushState可额外设置title属性供后续使用；</li>
                <li>hash兼容IE8以上，history兼容IE10以上；</li>
                <li>history模式需要后端配合将所有访问都指向index.html，否则用户刷新页面，会导致404错误。</li>
            </ol>
        </blockquote>
        <h4 id="%E5%85%AD%C2%A0%E3%80%81Vue3%E7%AF%87"><a name="t12"></a>六&nbsp;、Vue3篇</h4>
        <h5 id="1%E3%80%81Vue2.0%E5%92%8CVue3.0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">1、Vue2.0和Vue3.0的区别？</h5>
        <blockquote>
            <ul>
                <li><strong>前言</strong></li>
            </ul>
            <p>vue经历从2.0到3.0更新之后，简⽽⾔之就是变得更轻，更快，使⽤起来更加⽅便，每⼀次的版本迭代都是对上⼀个版本的升级优化，不管
                是对于我们开发者还是对于⽤户体验都是不断地在越来越⽅便，接下来我会着重于开发者来说⼀下两个不同版本的区别</p>
            <ul>
                <li><strong>详解</strong></li>
            </ul>
            <ol>
                <li><a href="https://so.csdn.net/so/search?q=vue2&amp;spm=1001.2101.3001.7020"
                        title="Vue2">Vue2</a>和<strong>vue3</strong>的初始化就存在着⼀定区别，⽐如vue3.0可以在安装脚⼿架同时提前安装好⼀些项⽬开发必备的插件，并且3.0提供了可视化创建脚⼿架，可以更加⽅便的对插件和依赖进⾏管理和配置，同时两个版本的⽬录结构也是有些许差别的。<span
                        style="color:#fe2c24;">（比如：Vue3相对于Vue2，打包工具Vite替代了webpack；TS替代了JS，pinia替代了vuex；Element-plus替代了Element等等）</span>
                </li>
                <li>在开发过程中两个版本的使⽤⽅法虽然在表⾯上没有太⼤的⼀个区别，但是在他的底层⽅⾯去看的话区别还是很⼤的，其中就包括渲染⽅式，数据监听，<a
                        href="https://so.csdn.net/so/search?q=%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A&amp;spm=1001.2101.3001.7020"
                        title="双向绑定">双向绑定</a>，⽣命周期，vue3更精准变更通知，这⾥着重说⼀下关于<strong>双向绑定</strong>的更新，</li>
            </ol>
            <ul>
                <li><strong>vue2</strong>&nbsp;的双向数据绑定是利⽤ES5的⼀个 API ，<strong>Object.definePropert()对数据进⾏劫持
                        结合发布订阅模式的⽅式来实现的</strong>。</li>
                <li><strong>vue3</strong>&nbsp;中使⽤了 ES6 的<strong> ProxyAPI 对数据代理</strong>，通过 reactive() 函数给每⼀个对象都包⼀层
                    Proxy，通过 Proxy 监听属性的变化，从⽽实现对数据的监控。</li>
            </ul>
        </blockquote>
        <h5 id="2%E3%80%81Vue3%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88%E6%94%B9%E5%8F%98%EF%BC%9F%C2%A0">
            2、Vue3带来了什么改变？&nbsp;</h5>
        <blockquote>
            <p><strong>性能的提升</strong></p>
            <ul>
                <li>
                    <p>打包大小减少41%</p>
                </li>
                <li>
                    <p>初次渲染快55%, 更新渲染快133%</p>
                </li>
                <li>
                    <p>内存减少54%</p>
                </li>
            </ul>
            <p><strong>源码的升级</strong></p>
            <ul>
                <li>
                    <p>使用Proxy代替<a href="https://so.csdn.net/so/search?q=defineProperty&amp;spm=1001.2101.3001.7020"
                            title="defineProperty">defineProperty</a>实现响应式</p>
                </li>
                <li>
                    <p>重写<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9FDOM&amp;spm=1001.2101.3001.7020"
                            title="虚拟DOM">虚拟DOM</a>的实现和Tree-Shaking</p>
                </li>
            </ul>
            <p><strong>拥抱TypeScript</strong></p>
            <ul>
                <li>
                    <p>Vue3可以更好的支持TypeScript</p>
                </li>
            </ul>
            <p><strong>新的特性</strong></p>
            <ul>
                <li>Composition API（组合API）</li>
            </ul>
            <p>（1）setup配置</p>
            <p>（2）ref与reactive</p>
            <p>（3）watch与watchEffect</p>
            <p>（4）provide与inject</p>
            <ul>
                <li>新的内置组件</li>
            </ul>
            <p>（1）Fragment</p>
            <p>（2）Teleport</p>
            <p>（3）Suspense</p>
            <ul>
                <li>其他改变</li>
            </ul>
            <p>（1）新的生命周期钩子</p>
            <p>（2）data 选项应始终被声明为一个函数</p>
            <p>（3）移除keyCode支持作为 v-on 的修饰符</p>
        </blockquote>
        <h5
            id="3%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%88vue2%E5%92%8Cvue3%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AF%B9%E6%AF%94%EF%BC%89%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">
            3、生命周期（vue2和vue3的生命周期对比）有哪些？</h5>
        <p><strong>vue2.x的生命周期</strong></p>
        <p style="text-align:center;"><strong><img alt="" class="left" height="1200"
                    src="https://i-blog.csdnimg.cn/blog_migrate/10a0605a8119d4b490f504b823942fb2.png"
                    width="684"></strong></p>
        <p><strong>vue3.0的生命周期</strong></p>
        <p style="text-align:center;"><strong><img alt="" height="1141"
                    src="https://i-blog.csdnimg.cn/blog_migrate/8c12425f4967063b51647b1467269bfb.png"
                    width="721"></strong></p>
        <p><strong>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：</strong></p>
        <ul>
            <li>beforeDestroy改名为 beforeUnmount</li>
            <li>destroyed改名为 unmounted</li>
        </ul>
        <p><strong>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：</strong></p>
        <ul>
            <li>beforeCreate===&gt;setup()</li>
            <li>created=======&gt;setup()</li>
            <li>beforeMount ===&gt;onBeforeMount</li>
            <li>mounted=======&gt;onMounted</li>
            <li>beforeUpdate===&gt;onBeforeUpdate</li>
            <li>updated =======&gt;onUpdated</li>
            <li>beforeUnmount ==&gt;onBeforeUnmount</li>
            <li>unmounted =====&gt;onUnmounted</li>
        </ul>
        <h5
            id="4%E3%80%81Vue3.0%E4%B8%AD%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9Fvue2%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
            4、Vue3.0中的<a href="https://so.csdn.net/so/search?q=%E5%93%8D%E5%BA%94%E5%BC%8F&amp;spm=1001.2101.3001.7020"
                title="响应式">响应式</a>原理是什么？vue2的响应式原理是什么？</h5>
        <p><strong>vue2.x的响应式</strong></p>
        <ul>
            <li>实现原理：
                <ul>
                    <li>对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。</li>
                    <li>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</li>
                </ul>
            </li>
        </ul>
        <p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
            Object.defineProperty(data, 'count', {<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
            &nbsp; &nbsp;get () {&nbsp; },&nbsp;<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
            &nbsp; &nbsp;set () {&nbsp;&nbsp;},<br> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
            &nbsp; &nbsp; &nbsp; &nbsp; })</p>
        <ul>
            <li>存在问题：
                <ul>
                    <li>新增属性、删除属性, 界面不会更新。</li>
                    <li>直接通过下标修改数组, 界面不会自动更新。</li>
                </ul>
            </li>
        </ul>
        <p><strong>Vue3.0的响应式</strong></p>
        <ul>
            <li>实现原理:
                <ul>
                    <li>通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</li>
                    <li>通过Reflect（反射）: 对源对象的属性进行操作。</li>
                    <li>MDN文档中描述的Proxy与Reflect：
                        <ul>
                            <li>Proxy：Proxy - JavaScript | MDN</li>
                            <li>Reflect：Reflect - JavaScript | MDN</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <p>new Proxy(data, {<br> &nbsp; &nbsp; // 拦截读取属性值<br> &nbsp; &nbsp; get (target, prop) {<br> &nbsp; &nbsp;
            &nbsp; &nbsp; return Reflect.get(target, prop)<br> &nbsp; &nbsp; },<br> &nbsp; &nbsp; // 拦截设置属性值或添加新属性<br>
            &nbsp; &nbsp; set (target, prop, value) {<br> &nbsp; &nbsp; &nbsp; &nbsp; return Reflect.set(target, prop,
            value)<br> &nbsp; &nbsp; },<br> &nbsp; &nbsp; // 拦截删除属性<br> &nbsp; &nbsp; deleteProperty (target, prop)
            {<br> &nbsp; &nbsp; &nbsp; &nbsp; return Reflect.deleteProperty(target, prop)<br> &nbsp; &nbsp; }<br> })<br>
            &ZeroWidthSpace;<br> proxy.name = 'tom' &nbsp;&nbsp;</p>
        <ul>
            <li>vue3响应式数据的判断
                <ul>
                    <li>isRef: 检查一个值是否为一个 ref 对象</li>
                    <li>isReactive: 检查一个对象是否是由 reactive 创建的响应式代理</li>
                    <li>isReadonly: 检查一个对象是否是由 readonly 创建的只读代理</li>
                    <li>isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理</li>
                </ul>
            </li>
        </ul>
        <h5 id="5%E3%80%81vue3%E7%9A%84%E5%B8%B8%E7%94%A8%20Composition%20API%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">
            5、vue3的常用 Composition API有哪些？</h5>
        <p><strong>1.拉开序幕的setup</strong></p>
        <ol>
            <li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
            <li>setup是所有Composition API（组合API）“ 表演的舞台 ”。</li>
            <li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
            <li>setup函数的两种返回值：</li>
        </ol>
        <ul>
            <li>&nbsp;&nbsp;&nbsp;若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重关注！）</li>
            <li>&nbsp; &nbsp;若返回一个渲染函数：则可以自定义渲染内容。（了解）</li>
        </ul>
        <p>&nbsp; &nbsp; &nbsp;5.setup的几个注意点</p>
        <ul>
            <li>&nbsp;setup执行的时机</li>
            <li>&nbsp;在beforeCreate之前执行一次，this是undefined。</li>
            <li>setup的参数</li>
            <li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
            <li>context：上下文对象</li>
            <li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。</li>
            <li>slots: 收到的插槽内容, 相当于 this.$slots。</li>
            <li>emit: 分发自定义事件的函数, 相当于 this.$emit。</li>
            <li>尽量不要与Vue2.x配置混用</li>
        </ul>
        <p>Vue2.x配置（data、methos、computed...）中可以访问到setup中的属性、方法。</p>
        <p>但在setup中不能访问到Vue2.x配置（data、methos、computed...）。</p>
        <p>如果有重名, setup优先。</p>
        <p>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）
        </p>
        <h5 id="%C2%A06%E3%80%81ref%E5%87%BD%E6%95%B0">6、Vue3中的ref函数</h5>
        <ul>
            <li>
                <p>作用: 定义一个响应式的数据</p>
            </li>
            <li>
                <p>语法:&nbsp;<code>const xxx = ref(initValue)</code></p>
                <ul>
                    <li>
                        <p>创建一个包含响应式数据的<strong>引用对象（reference对象，简称ref对象）</strong>。</p>
                    </li>
                    <li>
                        <p>JS中操作数据：&nbsp;<code>xxx.value</code></p>
                    </li>
                    <li>
                        <p>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;{<!-- -->{xxx}}&lt;/div&gt;</code></p>
                    </li>
                </ul>
            </li>
            <li>备注：
                <ul>
                    <li>
                        <p>接收的数据可以是：基本类型、也可以是对象类型。</p>
                    </li>
                    <li>
                        <p>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</p>
                    </li>
                    <li>
                        <p>对象类型的数据：内部&nbsp;<em>“ 求助 ”</em>&nbsp;了Vue3.0中的一个新函数——&nbsp;<code>reactive</code>函数。</p>
                    </li>
                </ul>
            </li>
        </ul>
        <h4 id="%E5%85%AD%E3%80%81React%E7%AF%87"><a name="t13"></a>七、React篇</h4>
        <h5 id="1%E3%80%81%E8%AE%B2%E8%AE%B2%E4%BB%80%E4%B9%88%E6%98%AF%20JSX%20%EF%BC%9F">1、讲讲什么是 JSX ？</h5>
        <p>当&nbsp;<strong>Facebook</strong>&nbsp;第一次发布 React 时，他们还引入了一种新的 JS 方言&nbsp;<code>JSX</code>，将原始 HTML 模板嵌入到 JS
            代码中。JSX 代码本身不能被浏览器读取，必须使用<code>Babel</code>和<code>webpack</code>等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React
            结合在一直了。</p>
        <pre data-index="54" class="set-code-show"
            name="code"><code class="language-XML hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">class MyComponent extends React.Component {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  render() {</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    let props = this.props;  </div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    return (</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"my-component"</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">{props.url}</span>&gt;</span>{props.name}<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">    );</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">  }</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">}</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <blockquote>
            <ul>
                <li>JSX的特点</li>
                <li>可以将HTML语言直接写在JavaScript语言之中，不加任何引号，这就是JSX的语法，它允许HTML与JavaScript的混写。</li>
                <li>JSX允许直接在模板插入JavaScript变量。如果这个变量是一个数组，则会展开这个数组的所有成员。</li>
                <li>防注入攻击</li>
                <li>在JSX中嵌入用户输入是安全的；</li>
                <li>React DOM在渲染之前默认会过滤所有传入的值。它可以确保应用不会被注入攻击。所有的内容在渲染之前都被转换成了字符串。这样可以有效地防止XSS(跨站脚本攻击)</li>
                <li>Babel转译器会把JSX转换成一个名为React.createElement()的方法调用。</li>
                <li>如果在普通的html里面要写jsx语法，要将script的type改成text/jsx，这是因为React独有的JSX语法跟JavaScript不兼容。凡是使用JSX的地方，都要加上type=“text/jsx”。其次，React提供俩个库:react.js和JSXTransformer.js，它们必须首先加载。其中，JSXTransformer.js的作用是将JSX语法转为JavaScript语法。这一步很消耗时间，实际上线的时候，应该把它放到服务器完成。
                </li>
            </ul>
        </blockquote>
        <h5
            id="2%E3%80%81React%20%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">
            2、React 的生命周期方法有哪些？</h5>
        <p>React的生命周期方法有很多，并且在不同的React版本中可能会有一些变化。为了更好地理解React的生命周期，我将它们按照React 16版本及其之后的版本进行整理，以帮助你更好地理解。</p>
        <p>在React 16版本及其之后，React的生命周期方法可分为三个阶段：<strong>挂载阶段、更新阶段和卸载阶段</strong>。以下是React 16版本及其之后的生命周期方法列表：</p>
        <p><strong>挂载阶段</strong>：</p>
        <blockquote>
            <ul>
                <li>constructor：组件实例化时调用，用于初始化状态和绑定方法。</li>
                <li>static getDerivedStateFromProps：在渲染之前调用，用于根据新的属性值计算并返回一个新的状态。</li>
                <li>render：渲染组件的内容。</li>
                <li>componentDidMount：组件挂载后调用，可以进行异步操作、订阅事件等。</li>
            </ul>
        </blockquote>
        <p><strong>更新阶段</strong>：</p>
        <blockquote>
            <ul>
                <li>static getDerivedStateFromProps：在渲染之前调用，用于根据新的属性值计算并返回一个新的状态。</li>
                <li>shouldComponentUpdate：在渲染之前调用，用于决定是否重新渲染组件，默认返回true。</li>
                <li>render：渲染组件的内容。</li>
                <li>getSnapshotBeforeUpdate：在最终将内容渲染到DOM之前调用，用于获取DOM更新前的快照。</li>
                <li>componentDidUpdate：组件更新后调用，可以进行DOM操作、发起网络请求等。</li>
            </ul>
        </blockquote>
        <p><strong>卸载阶段</strong>：</p>
        <blockquote>
            <ul>
                <li>componentWillUnmount：组件卸载前调用，可以进行清理操作，如取消订阅、清除定时器等。</li>
            </ul>
        </blockquote>
        <p>另外，React 16.3版本后引入了以下生命周期方法：</p>
        <blockquote>
            <ul>
                <li>static getDerivedStateFromError：在子组件渲染过程中，如果发生错误，会调用该方法，返回一个新的状态。</li>
                <li>componentDidCatch：在子组件渲染过程中，如果发生错误，会调用该方法，用于记录错误信息或上报错误。</li>
            </ul>
        </blockquote>
        <p>需要注意的是，React
            17版本之后，一些生命周期方法被标记为过时，并推荐使用其他替代方法来实现相应的功能。在使用React时，可以根据具体的需求和React版本来选择合适的生命周期方法。同时，React还提供了钩子函数的方式（如useEffect钩子）来完成与生命周期相关的操作，这也是React
            16.8版本及其之后的新特性。&nbsp;</p>
        <h5 id="articleContentId">3、React的Hooks详解</h5>
        <ul>
            <li><strong>Hook是什么</strong></li>
        </ul>
        <p>Hook 是一些可以让你在函数组件里“钩入” React state 及生命周期等特性的函数。Hook 不能在 class 组件中使用 —— 这使得你不使用 class 也能使用 React。<br> React
            内置了一些像 useState 这样的 Hook。你也可以创建你自己的 Hook 来复用不同组件之间的状态逻辑。</p>
        <p>React提供了多个常用的Hooks，用于在函数组件中管理状态、处理副作用和访问React的上下文等。以下是React所有的常用Hooks列表：</p>
        <ol>
            <li>useState：用于在函数组件中添加状态。</li>
            <li>useEffect：用于在函数组件中执行副作用操作。</li>
            <li>useContext：用于在函数组件中访问React的上下文。</li>
            <li>useReducer：用于在函数组件中使用Reducer模式来管理状态。</li>
            <li>useRef：用于在函数组件中创建可变的引用。</li>
            <li>useMemo：用于在函数组件中缓存计算的值。</li>
            <li>useCallback：用于在函数组件中缓存函数。</li>
            <li>useLayoutEffect：类似于useEffect，但在DOM更新之后同步执行。</li>
            <li>useImperativeHandle：用于在函数组件中自定义外部组件实例的暴露。</li>
            <li>useDebugValue：用于在自定义Hooks中显示自定义的调试值。</li>
        </ol>
        <p>这些Hooks可以帮助你更方便地编写和管理React函数组件。同时，你还可以根据需要自定义自己的Hooks来封装和复用逻辑。React的Hooks特性在React
            16.8版本及其之后引入，它们提供了一种更简洁、灵活的方式来编写可复用的React组件逻辑。</p>
        <h5
            id="4%E3%80%81React%E5%92%8CVue.js%E7%9A%84%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%92%8C%E5%B7%AE%E5%BC%82%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
            4、<strong>React和Vue.js的相似性和差异性是什么？</strong></h5>
        <p>相似性如下。</p>
        <p>（1）都是用于创建UI的 JavaScript库。</p>
        <p>（2）都是快速和轻量级的代码库（这里指 React核心库）。</p>
        <p>（3）都有基于组件的架构。</p>
        <p>（4）都使用虚拟DOM。</p>
        <p>（5）都可以放在单独的HTML文件中，或者放在 Webpack设置的一个更复杂的模块中。</p>
        <p>（6）都有独立但常用的路由器和状态管理库。</p>
        <p>它们最大的区别在于 Vue. js通常使用HTML模板文件，而 React完全使用 JavaScript创建虚拟DOM。 Vue. js还具有对于“可变状态”的“
            reactivity”的重新渲染的自动化检测系统。（React一般适用于大型项目）</p>
        <h5 id="5%E3%80%81React%E7%9A%84%E5%8A%9F%E8%83%BD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0">
            5、React的功能是什么？&nbsp;</h5>
        <p>React的主要功能如下：</p>
        <ol>
            <li>
                <p>它使用<strong>虚拟DOM</strong>而不是真实DOM。</p>
            </li>
            <li>
                <p>它使用<strong>服务器端渲染</strong>。</p>
            </li>
            <li>
                <p>它遵循<strong>单向数据流</strong>或数据绑定。</p>
            </li>
        </ol>
        <h5 id="6%E3%80%81React%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%BB%E8%A6%81%E4%BC%98%E7%82%B9%E6%98%AF%EF%BC%9F">
            6、React的一些主要优点是？</h5>
        <ol>
            <li>
                <p>它提高了应用程序的性能</p>
            </li>
            <li>
                <p>它可以方便地在客户端和服务器端使用</p>
            </li>
            <li>
                <p>由于有了JSX，代码的可读性提高了</p>
            </li>
            <li>
                <p>React易于与其他框架（如Meteor，Angular等）集成</p>
            </li>
            <li>
                <p>使用React，编写UI测试用例变得非常容易</p>
            </li>
        </ol>
        <h5 id="7.%20React%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">7、React的局限性是什么？</h5>
        <ol>
            <li>
                <p>React只是一个库，而不是一个成熟的框架</p>
            </li>
            <li>
                <p>它的图书馆很大，需要花费一些时间来理解</p>
            </li>
            <li>
                <p>对于新手程序员而言，理解起来可能有点困难</p>
            </li>
            <li>
                <p>由于使用内联模板和JSX，编码变得复杂</p>
            </li>
        </ol>
        <h5
            id="8%E3%80%81%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3React%20State%E4%B8%8D%E5%8F%AF%E5%8F%98%E6%80%A7%E7%9A%84%E5%8E%9F%E5%88%99">
            8、如何理解React State不<a
                href="https://so.csdn.net/so/search?q=%E5%8F%AF%E5%8F%98%E6%80%A7&amp;spm=1001.2101.3001.7020"
                title="可变性">可变性</a>的原则</h5>
        <p>在 React 中，不可变性是指数据一旦被创建，就不能被修改。React 推崇使用不可变数据的原则，这意味着在更新数据时，应该创建新的数据对象而不是直接修改现有的数据。</p>
        <p><strong>以下是理解 React 中不可变性原则的几个关键点：</strong></p>
        <ol>
            <li><strong>数据一旦创建就不能被修改：</strong>在 React 中，组件的状态（<span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">state</span></span>）和属性（<span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">props</span></span>）应该被视为不可变的。一旦创建了状态或属性对象，就不应该直接修改它们的值。这样可以确保组件的数据在更新时是不可变的，从而避免意外的数据改变和副作用。
            </li>
            <li><strong>创建新的数据对象：</strong>当需要更新状态或属性时，应该创建新的数据对象。这可以通过使用对象展开运算符、数组的 <span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">concat()、slice()</span></span> 等方法，或者使用不可变数据库（如<span
                    style="color:#be191c;"><span style="background-color:#fef2f0;">Immutable.js</span></span>、<span
                    style="color:#be191c;"><span style="background-color:#fef2f0;">Immer </span></span>等）来创建新的数据副本。</li>
            <li><strong>比较数据变化：</strong>React 使用 <span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">Virtual DOM
                    </span></span>来比较前后两个状态树的差异，并仅更新需要更新的部分。通过使用不可变数据，React 可以更高效地进行比较，因为它可以简单地比较对象引用是否相等，而不必逐个比较对象的属性。
            </li>
            <li><strong>性能优化：</strong>使用不可变数据可以带来性能上的优势。由于 React 可以更轻松地比较前后状态的差异，可以减少不必要的重新渲染和组件更新，提高应用的性能和响应性。</li>
        </ol>
        <p><strong>不可变性的原则在 React 中有以下好处：</strong></p>
        <ol>
            <li><strong>简化数据变更追踪：</strong>由于数据不可变，可以更轻松地追踪数据的变化。这样可以更好地理解代码的行为和数据的流动。</li>
            <li><strong>避免副作用：</strong>可变数据容易引发副作用和难以追踪的 bug。通过使用不可变数据，可以避免许多与副作用相关的问题。</li>
            <li><strong>方便的历史记录和回滚：</strong>不可变数据使得记录和回滚应用状态的历史变得更容易。可以在不改变原始数据的情况下，创建和保存不同时间点的数据快照</li>
        </ol>
        <h5
            id="9%E3%80%81React%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E5%85%B3%E9%94%AE%E7%89%88%E6%9C%AC%E5%8C%BA%E5%88%AB%EF%BC%9F">
            9、React的特点和关键版本区别？</h5>
        <ul>
            <li>react的关键版本</li>
        </ul>
        <p>React16之前对virtural dom的更新和渲染是同步的。就是当一次更新或者一次加载开始以后，diff virtual
            dom并且渲染的过程是一口气完成的。如果组件层级比较深，相应的堆栈也会很深，长时间占用浏览器主线程，一些类似用户输入、鼠标滚动等操作得不到响应。</p>
        <ul>
            <li>React16开始用了分片的方式解决上面的问题</li>
        </ul>
        <p>就是把一个任务分成很多小片，当分配给这个小片的时间用尽的时候，就检查任务列表中有没有新的、优先级更高的任务，有就做这个新任务，没有就继续做原来的任务。这种方式被叫做异步渲染(Async Rendering)。</p>
        <ul>
            <li>React的特点</li>
        </ul>
        <p><strong>1. React速度很快</strong><br> 与其他框架相比，React采取了一种独特操作DOM的方式。<br>
            它并不直接对DOM进行操作。它引入了一个叫虚拟DOM的概念，安插在JavaScript逻辑和实际的DOM之间。这一概念提高了Web性能。在UI渲染过程中，React通过在虚拟DOM中的微操作来实现对实际DOM的局部更新。<br>
            将视图与数据进行单向绑定，绝大部分操作都可以不再直接操作DOM，而是通过改变数据来更新视图，这对于前端是具有里碑意义的。<br><strong>2. 跨浏览器兼容</strong><br>
            虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。<br><strong>3. 模块化</strong><br>
            为程序编写独立的模块化UI组件，并且它们可以引入其他组件。这等同于提高了代码的可维护性。<br><strong>4. 单向数据流，让事情一目了然</strong><br>
            Flux是一个用于在JavaScript应用中创建单向数据层的架构，它随着React视图库的开发而被Facebook概念化。它只是一个概念，而非特定工具的实现。它可以被其它框架吸纳。例如，Alex
            Rattray有一个很好的Flux实例，在React中使用了Backbone的集合和模型。<br><strong>5. 纯粹的JavaScript</strong><br>
            现代Web应用程序与传统的Web应用有着不同的工作方式。<br> 例如，视图层的更新需要通过用户交互而不需要请求服务器。因此视图和控制器非常依赖彼此。<br>
            许多框架使用Handlebars或Mustache等模板引擎来处理视图层。但React相信视图和控制器应该相互依存在一起而不是使用第三方模板引擎，而且最重要的是，它是纯粹的JavaScript程序。<br><strong>6.
                同构的JavaScript</strong><br> 单页面JS应用程序的最大缺陷在于对搜索引擎的索引有很大限制。React对此有了解决方案。<br>
            React可以在服务器上预渲染应用再发送到客户端。它可以从预渲染的静态内容中恢复一样的记录到动态应用程序中。<br>
            因为搜索引擎的爬虫程序依赖的是服务端相应而不是JavaScript的执行，预渲染你的应用有助于搜索引擎优化。<br><strong>7. React与其他框架/库相比兼容性好</strong><br>
            比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏。<br><strong>8.
                相比于其他的框架【vue】更灵活</strong><br>
            没有那么多的条条框框，提供了一系列基础api自己随意组合。如果要我把他比作积木的话那么react提供的就是小型的积木，vue提供的是大型的积木。这就势必造成了react会比vue更加的灵活。</p>
        <h4
            id="%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E5%85%AD%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A">
            <a name="t14"></a><span style="color:#0d0016;">八、</span>uniapp篇</h4>
        <h5 id="1%E3%80%81uniapp%E4%BC%98%E7%BC%BA%E7%82%B9">1、<strong>uniapp优缺点</strong></h5>
        <blockquote>
            <p>uniapp官网：<a href="https://uniapp.dcloud.net.cn/component/" rel="nofollow"
                    title="组件使用的入门教程 | uni-app官网">组件使用的入门教程 | uni-app官网</a></p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">优点</span></span></p>
            <ul>
                <li>&nbsp;&nbsp; &nbsp;一套代码可以生成多端</li>
                <li>&nbsp;&nbsp; &nbsp;学习成本低,语法是vue的,组件是小程序的</li>
                <li>&nbsp;&nbsp; &nbsp;拓展能力强</li>
                <li>&nbsp;&nbsp; &nbsp;使用HBuilderX开发,支持vue语法</li>
                <li>&nbsp;&nbsp; &nbsp;突破了系统对H5调用原生能力的限制</li>
            </ul>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">&nbsp;缺点</span></span></p>
            <ul>
                <li>&nbsp;&nbsp; &nbsp;问世时间短,很多地方不完善</li>
                <li>&nbsp;&nbsp; &nbsp;社区不大</li>
                <li>&nbsp;&nbsp; &nbsp;官方对问题的反馈不及时</li>
                <li>&nbsp;&nbsp; &nbsp;在Android平台上比微信小程序和iOS差</li>
                <li>&nbsp;&nbsp; &nbsp;文件命名受限</li>
            </ul>
        </blockquote>
        <h5 id="2%E3%80%81uniapp%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">2、uniapp目录结构</h5>
        <p>一个uni-app工程，默认包含如下目录及文件：</p>
        <blockquote>
            <pre data-index="55" class="set-code-hide"
                name="code"><code class="language-XML hljs"><ol class="hljs-ln" style="width:805px"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">┌─uniCloud              云空间目录，阿里云为uniCloud-aliyun,腾讯云为uniCloud-tcb（详见uniCloud）</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">│─components            符合vue组件规范的uni-app组件目录</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">│  └─comp-a.vue         可复用的a组件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─utssdk                存放uts文件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─pages                 业务页面文件存放的目录</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="6"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">│  ├─index</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="7"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">│  │  └─index.vue       index页面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="8"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">│  └─list</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="9"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">│     └─list.vue        list页面</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="10"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─static                存放应用引用的本地静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="11"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─uni_modules           存放[uni_module](/uni_modules)。</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="12"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─platforms             存放各平台专用页面的目录，详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="13"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─nativeplugins         App原生语言插件 详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="14"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─nativeResources       App端原生资源目录</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="15"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">│  └─android            Android原生资源目录 详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="16"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─hybrid                App端存放本地html文件的目录，详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="17"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─wxcomponents          存放小程序组件的目录，详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="18"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─unpackage             非工程代码，一般存放运行或发行的编译结果</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="19"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─AndroidManifest.xml   Android原生应用清单文件 详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="20"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─main.js               Vue初始化入口文件</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="21"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="22"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="23"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">├─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="24"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">└─uni.scss              这里是uni-app内置的常用样式变量</div></div></li></ol></code><div class="hide-preCode-box"><span class="hide-preCode-bt" data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7365&quot;}"><img class="look-more-preCode contentImg-no-view" src="https://csdnimg.cn/release/blogv2/dist/pc/img/newCodeMoreWhite.png" alt="" title=""></span></div><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">pages.json&nbsp;&nbsp;</span></span>
            </p>
            <p>配置文件，全局页面路径配置，应用的状态栏、导航条、标题、窗口背景色设置等<br><span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">main.js&nbsp;&nbsp;</span></span></p>
            <p>入口文件，主要作用是初始化vue实例、定义全局组件、使用需要的插件如
                vuex，注意uniapp无法使用vue-router，路由须在pages.json中进行配置。如果开发者坚持使用vue-router，可以在插件市场找到转换插件。<br><span
                    style="color:#be191c;"><span style="background-color:#fef2f0;">App.vue</span></span><br>
                是uni-app的主组件，所有页面都是在App.vue下进行切换的，是页面入口文件。但App.vue本身不是页面，这里不能编写视图元素。除此之外，应用生命周期仅可在App.vue中监听，在页面监听无效。<br><span
                    style="color:#be191c;"><span style="background-color:#fef2f0;">pages</span></span><br>
                页面管理部分用于存放页面或者组件</p>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">应用配置&nbsp;manifest.json&nbsp;
                    </span></span></p>
            <p>文件是应用的配置文件，用于指定应用的名称、图标、权限等，HBuilderX 创建的工程此文件在根目录，CLI 创建的工程此文件在 src 目录。我们也可以在这里为Vue 为H5设置<a
                    href="https://so.csdn.net/so/search?q=%E8%B7%A8%E5%9F%9F&amp;spm=1001.2101.3001.7020"
                    title="跨域">跨域</a>拦截处理器<br><span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">package.json</span></span></p>
            <p>文件用来对 uni-app 进行全局配置，决定页面文件的路径、窗口样式、原生的导航栏、底部的原生tabbar 等。</p>
            <p>pages数组中第一项表示应用启动页，参考官网：<a href="https://uniapp.dcloud.io/collocation/pages" rel="nofollow"
                    title="pages.json 页面路由 | uni-app官网">pages.json 页面路由 | uni-app官网</a></p>
        </blockquote>
        <h5 id="%C2%A04%E3%80%81uniapp%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4%E8%AF%AD%E5%8F%A5">4、uniapp
            常用的指令语句</h5>
        <ul>
            <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;v-for：循环渲染 （注意加：key）</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; v-if ：控制元素的删除添加 &nbsp; &nbsp; &nbsp;&nbsp;</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; v-show：控制元素的显示隐藏</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; v-model：双向数据绑定</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; v-on：事件绑定（简写<span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">@</span></span>）</li>
            <li>&nbsp; &nbsp; &nbsp; &nbsp; v-bind：属性绑定（简写<span style="color:#be191c;"><span
                        style="background-color:#fef2f0;">：</span></span>）</li>
        </ul>
        <h5
            id="5%E3%80%81uniapp%20%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E3%80%81%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">
            5、uniapp 应用的生命周期、页面的生命周期、组件的生命周期</h5>
        <blockquote>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">应用的生命周期</span></span></p>
            <ul>
                <li>onLaunch——当uni-app 初始化完成时触发（全局只触发一次）</li>
                <li>onShow——当 uni-app 启动，或从后台进入前台显示</li>
                <li>onHide——当 uni-app 从前台进入后台</li>
                <li>onError——当 uni-app 报错时触发</li>
                <li>onUniNViewMessage——对 nvue 页面发送的数据进行监听，可参考 nvue 向 vue 通讯</li>
                <li>onUnhandledRejection——对未处理的 Promise 拒绝事件监听函数（2.8.1+）</li>
                <li>onPageNotFound——页面不存在监听函数</li>
                <li>onThemeChange——监听系统主题变化&nbsp;</li>
            </ul>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">页面的生命周期</span></span></p>
            <ul>
                <li>onInit——监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad</li>
                <li>onLoad——监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考示例</li>
                <li>onShow——监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面</li>
                <li>onReady——监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发</li>
                <li>onHide——监听页面隐藏</li>
                <li>onUnload——监听页面卸载</li>
                <li>onResize——监听窗口尺寸变化</li>
            </ul>
            <p><span style="color:#be191c;"><span style="background-color:#fef2f0;">组件的生命周期</span></span><br> uni-app
                组件支持的生命周期，与vue标准组件的生命周期相同</p>
            <ul>
                <li>beforeCreate——在实例初始化之后被调用。</li>
                <li>created——在实例创建完成后被立即调用。</li>
                <li>beforeMount——在挂载开始之前被调用。</li>
                <li>mounted——挂载到实例上去之后调用。详见 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用$nextTickVue官方文档</li>
                <li>beforeUpdate——数据更新时调用，发生在虚拟 DOM 打补丁之前。</li>
                <li>updated——由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</li>
                <li>beforeDestroy——实例销毁之前调用。在这一步，实例仍然完全可用。</li>
                <li>destroyed——Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
            </ul>
        </blockquote>
        <h4 id="%E4%B9%9D%E3%80%81Webpack%E7%AF%87"><a name="t15"></a>九、Webpack篇</h4>
        <h5 id="1.Webpack%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><strong>1</strong>、<strong>Webpack是什么？</strong></h5>
        <blockquote>
            <ul>
                <li>webpack 是一个静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。</li>
                <li>webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。
                    这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。</li>
                <li>插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。
                </li>
            </ul>
        </blockquote>
        <h5
            id="2%E3%80%81Webpack%E7%9A%84%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B%2F%E6%89%93%E5%8C%85%E5%8E%9F%E7%90%86%2F%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B%EF%BC%9F%C2%A0">
            2、Webpack的打包过程/打包原理/构建流程？&nbsp;</h5>
        <p style="text-align:center;"><img alt=""
                src="https://i-blog.csdnimg.cn/blog_migrate/7bc4816f69e4ed31940a7e397303de57.png"></p>
        <p>webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来。命令行执行npx webpack打包命令开始</p>
        <ul>
            <li>1.初始化编译参数:从配置文件和shell命令中读取与合并参数</li>
            <li>2.开始编译:根据上一步得到的参数初始化Compiler对象，加载所有配置的Plugin，执行对象的 run 方法开始执行编译。</li>
            <li>3.确定入口:根据配置中的 entry 找出所有的入口文件</li>
            <li>4.编译模块:从入口文件触发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，然后递归本步骤直到所有入口依赖的文件都进行翻译。</li>
            <li>5.完成模块编译:在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系图。</li>
            <li>6.输出资源：根据依赖关系图，组装成一个个包含多个模块的Chunk，再把每个Chunk转化成一个单独的文件加入到输出列表，根据配置确定输出的路径和文件名输出。</li>
        </ul>
        <p>在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑。</p>
        <p>总结归纳：</p>
        <ul>
            <li>初始化:从配置文件和shell命令中读取与合并参数，根据参数初始化Compiler实例，加载Plugin(注册所有配置的插件)，调用Compiler实例的run方法开始执行编译。</li>
        </ul>
        <blockquote>
            <p>Compiler编译对象掌控者webpack生命周期，不执行具体的任务，只是进行一些调度工作。比如执行模块创建、依赖收集、分块、打包等<br>
                调用run之后，创建Compiltation实例，每次构建都会新创建一个Compiltation实例，包含了这次构建的基本信息<br> Webpack
                会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑。</p>
        </blockquote>
        <ul>
            <li>编译:从entry 触发，对每个Module 串行调用对应的 Loader对模块进行翻译，再找出该模块依赖的模块，递归进行编译处理。</li>
        </ul>
        <blockquote>
            <p>从配置文件（ webpack.config.js ）中指定的 entry 入口，开始解析文件构建&nbsp;<a
                    href="https://so.csdn.net/so/search?q=AST&amp;spm=1001.2101.3001.7020" title="AST">AST</a>&nbsp;语法树
            </p>
        </blockquote>
        <ul>
            <li>根据依赖关系图，组装成包含多个模块的Chunk，将个Chunk转换成文件输出。</li>
        </ul>
        <blockquote>
            <p>不同entry生成不同chunk，动态导入也会生成自己的chunk&nbsp;</p>
        </blockquote>
        <h5
            id="3%E3%80%81Webpack%E4%B8%ADloader%E7%9A%84%E4%BD%9C%E7%94%A8%2F%20loader%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
            3、Webpack中loader的作用/ loader是什么？</h5>
        <p>Loader 是webpack中提供了一种处理多种文件格式的机制，因为webpack只认识JS和JSON，所以Loader相当于翻译官，将其他类型资源进行预处理。<br> 用于对模块的"源代码"进行转换。<br>
            loader支持链式调用，原型调用的顺序是从右往左。原型链中的每个loader会处理之前已处理过的资源，最终变为js代码。<br> 可以通过 loader 的预处理函数，为 JavaScript
            生态系统提供更多能力。</p>
        <h5 id="4%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84loader%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">4、常见的loader有哪些？</h5>
        <ul>
            <li>less-loader: 将less文件编译成css文件，开发中，我们常常会使用less预处理器编写css样式，使开发效率提高</li>
            <li>css-loader: 将css文件变成commonjs模块加载到js中，模块内容是样式字符串</li>
            <li>style-loader:&nbsp; 创建style标签，将js中的样式资源插入标签内，并将标签添加到head中生效</li>
            <li>ts-loader:&nbsp; 打包编译Typescript文件</li>
        </ul>
        <h5
            id="5%E3%80%81Plugin%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9FPlugin%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">
            5、Plugin有什么作用？Plugin是什么？</h5>
        <ul>
            <li>Plugin功能更强大，主要目的就是解决loader 无法实现的事情，比如打包优化和代码压缩等。</li>
            <li>Plugin加载后，在webpack构建的某个时间节点就会触发plugin定义的功能，帮助webpack做一些事情。实现对webpack的功能扩展。</li>
        </ul>
        <h5 id="6%E3%80%81%E5%B8%B8%E8%A7%81%E7%9A%84Plugin%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F">6、常见的Plugin有哪些？</h5>
        <ul>
            <li>html-webpack-plugin 处理html资源，默认会创建一个空的HTML，自动引入打包输出的所有资源（js/css）</li>
            <li>mini-css-extract-plugin 打包过后的css在js文件里，该插件可以把css单独抽出来</li>
            <li>clean-webpack-plugin 每次打包时候，CleanWebpackPlugin 插件就会自动把上一次打的包删除</li>
        </ul>
        <h5 id="7%E3%80%81Webpack%E4%B8%ADLoader%E5%92%8CPlugin%E7%9A%84%E5%8C%BA%E5%88%AB">7、Webpack中Loader和Plugin的区别
        </h5>
        <ul>
            <li>webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。
                这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。</li>
            <li>插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。</li>
        </ul>
        <h5
            id="8%E3%80%81%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8webpack%E6%9D%A5%E4%BC%98%E5%8C%96%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%EF%BC%9F">
            8、如何利用webpack来优化前端性能？</h5>
        <ul>
            <li>代码压缩</li>
        </ul>
        <p><strong>按需加载</strong></p>
        <ul>
            <li>代码分割 splitChunks - 在optimization配置项中配置</li>
        </ul>
        <blockquote>
            <p>1.可以将node__mudules中代码单独打包成一个chunk输出（比如使用了jqury？）<br> 2.会自动分析多入口chunk中，有没有公共的文件，如果有会打包成单独的一个chunk不会重复打包
            </p>
        </blockquote>
        <ul>
            <li>使用Dll进行分包</li>
        </ul>
        <blockquote>
            <p>正常情况下node_module会被打包成一个文件<br> 使用dll技术，对可以将那些不常更新的框架和库进行单独打包，生成一个chunk&nbsp;</p>
        </blockquote>
        <ul>
            <li>使用路由懒加载</li>
        </ul>
        <blockquote>
            <p>在代码中所有被 import()函数引用的模块，都将打成一个单独的包，放在 chunk 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。</p>
        </blockquote>
        <h5
            id="9%E3%80%81Webpack%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E5%8E%8B%E7%BC%A9%E4%BB%A3%E7%A0%81%EF%BC%9F%E5%8E%8B%E7%BC%A9%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F">
            9、Webpack如何配置压缩代码？压缩了什么？</h5>
        <ul>
            <li>在optimization配置项中来配置该插件作为压缩器进行压缩。</li>
            <li>在plugins里使用该插件进行压缩</li>
            <li>js压缩:利用terser-webpack-plugin</li>
            <li>css压缩:利用了optimize-css-assets-webpack-plugin 插件</li>
            <li>删除了console、注释、空格、换行、没有使用的css代码等</li>
        </ul>
        <h5
            id="10%E3%80%81%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98webpack%E7%9A%84%E6%9E%84%E5%BB%BA%E9%80%9F%E5%BA%A6%EF%BC%9F%C2%A0">
            10、如何提高webpack的构建速度？&nbsp;</h5>
        <p>思路1：减少需要构建的文件或代码</p>
        <ul>
            <li>HMR(Hot Module Replacement) 模块热替换只重新构建发生变化的模块 – 开发环境中</li>
            <li>缩小处理范围:合理利用这两个属性exclude：不需要处理的文件 和 include：需要处理的文件</li>
            <li>babel缓存 第二次构建时，会读取之前的缓存，只重新构建变化的文件</li>
            <li>使用Dll进行分包 --&gt; 分包方便按需加载</li>
        </ul>
        <blockquote>
            <p>正常情况下node_module会被打包成一个文件<br> 使用dll技术，对可以将那些不常更新的框架和库进行单独打包，生成一个chunk<br> 项目源代码也需要拆分，可以根据路由来划分打包文件 --&gt;
                怎么实现路由懒加载？webpack中如何实现组件异步加载？</p>
        </blockquote>
        <p>思路2：多进行进行构建&nbsp;</p>
        <ul>
            <li>多进程打包 thread-loader,将其放在费时的loader之前</li>
        </ul>
        <blockquote>
            <p>进程启动和进程通信都有开销，工作时间比较长，才需要多进程打包</p>
        </blockquote>
        <h4 id="%E5%8D%81%E3%80%81Git%2FSVN%E7%AF%87"><a name="t16"></a><br> 十、Git/SVN篇</h4>
        <h5 id="1%E3%80%81Git%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">1、Git是什么？</h5>
        <p>Git是目前世界上最先进的<a
                href="https://so.csdn.net/so/search?q=%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%B3%BB%E7%BB%9F&amp;spm=1001.2101.3001.7020"
                title="分布式版本控制系统">分布式版本控制系统</a>，旨在快速高效地处理从小型到大型项目的所有事务<br> 特性：易于学习，占用内存小，具有闪电般快速的性能<br> 使用Git和<a
                href="https://so.csdn.net/so/search?q=Gitlab%E6%90%AD%E5%BB%BA&amp;spm=1001.2101.3001.7020"
                title="Gitlab搭建">Gitlab搭建</a><a
                href="https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&amp;spm=1001.2101.3001.7020"
                target="_blank" class="hl hl-1"
                data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;word\&quot;:\&quot;版本控制\&quot;}&quot;}"
                data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://edu.csdn.net/cloud/sd_summit?utm_source=glcblog&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;word\&quot;:\&quot;版本控制\&quot;}&quot;}"
                data-tit="版本控制" data-pretit="版本控制">版本控制</a>环境是现在互联网公司最流行的版本控制方式</p>
        <h5
            id="2%E3%80%81%E7%AE%80%E8%BF%B0git%E4%B8%AD%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E6%96%B0%E5%A2%9E%E6%96%87%E4%BB%B6%E6%B7%BB%E5%8A%A0%E5%88%B0%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%EF%BC%9F">
            2、简述Git中如何将一个新增文件添加到本地仓库？</h5>
        <pre data-index="57" class="set-code-show"
            name="code"><code class="language-bash hljs"><ol class="hljs-ln" style="width:100%"><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="1"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git config --global user.name   <span class="hljs-string">'开发人员名称'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="2"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git add 文件名称/*      //将当前文件或当前文件夹下未添加到栈存区的文件添加栈存区</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="3"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git commit 文件名称/* -m <span class="hljs-string">'完善的注释'</span></div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="4"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">//将栈存区当前文件或当前文件夹下的全部文件添加到版本本地仓库</div></div></li><li><div class="hljs-ln-numbers"><div class="hljs-ln-line hljs-ln-n" data-line-number="5"></div></div><div class="hljs-ln-code"><div class="hljs-ln-line">git <span class="hljs-built_in">log</span>     //查看文件版本号</div></div></li></ol></code><div class="hljs-button {2}" data-title="复制" onclick="hljs.copyCode(event)"></div></pre>
        <h5 id="3%E3%80%81git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4">3、Git常用命令</h5>
        <p style="text-align:center;"><img alt=""
                src="https://i-blog.csdnimg.cn/blog_migrate/06f3568de1cdd242e7eab2021cc3e75f.png"></p>
        <blockquote>
            <p><strong>文字整理(可直接复制使用)</strong></p>
            <p>1、git config - - 可以配置git的参数，可以使用 git config --list查看已经配置的git参数。</p>
            <p>其中有三个级别的保存位置，</p>
            <ul>
                <li>–system（本系统）</li>
                <li>–global（当前用户，全局）</li>
                <li>–local（本地配置，当前目录）</li>
                <li>默认使用–local</li>
            </ul>
            <p>配置用户名及邮箱</p>
            <ul>
                <li>git config --global user.name “****”</li>
                <li>git config --global user.email 1********@qq.com</li>
            </ul>
            <p>2、git init - - 初始化代码仓库</p>
            <p>3、git clone - - 克隆远程仓库</p>
            <p>PS:如果希望在克隆的时候，自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p>
            <p>$ git clone git://github.com/schacon/grit.git mygrit</p>
            <p>4、git add - - 把需要提交的所有修改放到暂存区（Stage）</p>
            <ul>
                <li>git add file – 提交指定文件</li>
                <li>git add . || git add -A – 提交所有文件</li>
                <li>git add *.js – 提交所有.js格式文件</li>
                <li>git add -f file – 强制添加</li>
            </ul>
            <p>5、git diff - - 查看当前目录的所有修改(#当暂存区中没有文件时，git diff比较的是，工作区中的文件与上次提交到版本库中的文件。</p>
            <p>#当暂存区中有文件时，git diff则比较的是，当前工作区中的文件与暂存区中的文)</p>
            <ul>
                <li>git diff HEAD - - file – 比较工作区中的文件与版本库中文件的差异。HEAD指向的是版本库中的当前版本，而file指的是当前工作区中的文件。</li>
            </ul>
            <p>6、git commit -m “message” - - 提交代码</p>
            <p>7、git rm - - 会把文件从当前目录删除（不会保存删除的文件）。如果需要从Git仓库中删除，但保留在当前工作目录中，亦即从跟踪清单中删除，可以使用git rm -r --cached readme.md
            </p>
            <p>PS:如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
            <p>8、git log - - 查看历史记录，git log命令显示从最近到最远的提交日志</p>
            <ul>
                <li>git log --graph – 查看分支合并图</li>
            </ul>
            <p>9、git reflog - - 用来记录你的每一次命令</p>
            <p>10、git remote - - 查看当前的远程库</p>
            <p>11、git remote -v - - 可以显示对应的克隆地址（对于多个远程仓库很有用）</p>
            <p>12、git remote add [short_name][url] - - 可以添加新的远程仓库</p>
            <p>13、git remote add origin &lt; address &gt; - - 关联一个远程库</p>
            <p>14、git fetch [remote-name] - - 可以从远程仓库抓取数据到本地。【git fetch origin release/sprint-70】</p>
            <p>15、git pull - - 更新数据</p>
            <p>16、git push [remote_name] [branch_name] - - 推送数据到远程仓库 默认使用origin和master</p>
            <p>17、git push -u origin master [-f] - - 第一次将本地库的所有内容推送到远程库上</p>
            <p>18、git remote show origin - - 查看远程仓库信息</p>
            <p>19、git remote rename [old_name][new_name] - - 远程仓库重命名</p>
            <p>20、git remote rm [remote_name] - - 删除远程仓库</p>
            <p>21、git branch -d &lt; name &gt; - - 删除本地分支</p>
            <p>22、git tag - - 显示当前库中的标签</p>
            <p>23、git branch - - 可显示当前所有分支。可以使用–merged和–no-merged查看已经合并、未合并的分支。</p>
            <p>24、git branch &lt;branch_name&gt; - - 创建新分支</p>
            <p>25、git branch -r - - 查看远程仓库分支</p>
            <p>26、git checkout &lt;branch_name&gt; - - 切换到指定的分支</p>
            <p>27、git checkout -b &lt;branch_name&gt; - - 创建新分支并切换到该分支</p>
            <p>28、git merge 合并分支</p>
            <p>举例：</p>
            <ul>
                <li>将hotfix分支合并到master上需要：</li>
                <li>git checkout master</li>
                <li>git merge hotfix</li>
                <li>合并之后可以使用git branch -d hotfix删除分支。</li>
                <li>如果合并时存在冲突，需要手工修改</li>
                <li>合并分支时，加上—no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。</li>
            </ul>
            <p>29、git checkout . --恢复上次提交状态</p>
            <ul>
                <li>git checkout --file - - 文件在工作区的修改全部撤销</li>
                <li>一种是file修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
                <li>一种是file已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
            </ul>
            <p>30、git status – 用于显示工作目录和暂存区的状态。使用此命令能看到那些修改被暂存到了, 哪些没有, 哪些文件没有被Git tracked到。git
                status不显示已经commit到项目历史中去的信息。</p>
            <p>31、git reset --hard HEAD^ - - #版本回退</p>
            <ul>
                <li>git reset --hard commitId - - 取消回退，commitId为你想要回到的未来版本号</li>
                <li>PS:Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD，上上一个版本就是HEAD^，当回退版本较早时可以写成HEAD~100。</li>
            </ul>
            <p>32、git stash - - 储藏可以获取你工作目录的中间状态——也就是你修改过的被追踪的文件和暂存的变更——并将它保存到一个未完结变更的堆栈中，随时可以重新应用。</p>
            <ul>
                <li>现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行git
                    stash。把所有未提交的修改（包括暂存的和非暂存的）都保存起来，用于后续恢复当前工作目录。</li>
                <li>PS:需要说明一点，stash是本地的，不会通过git push命令上传到git server上。</li>
            </ul>
            <p>33、git stash list - - 查看现有的所有储藏，此命令显然暗示了git stash可以多次保存工作进度，并用在恢复时候选择。</p>
            <p>34、git stash pop [–index] [ &lt; stash &gt; ] - - 重新应用已经实施的储藏（删除储藏）</p>
            <ul>
                <li>如果不使用任何参数，会恢复最新保存的工作进度，并将恢复的工作进度从存储的工作进度列表中清除。</li>
                <li>如果提供&lt; stash&gt;参数（来自git stash list显示的列表），则从该&lt; stash&gt;中恢复。恢复完毕也将从进度列表中删除&lt; stash&gt;。</li>
                <li>选项–index除了恢复工作区的文件外，还尝试恢复暂存区。</li>
            </ul>
            <p>35、git stash drop [&lt; stash &gt;] - - 删除一个存储的进度。（默认删除最新的进度）</p>
            <p>36、git stash clear - - 清空当前所有的stash</p>
            <p>37、git stash branch &lt; branchname &gt; &lt; stash &gt; - - 基于储藏进度创建分支。</p>
        </blockquote>
        <h5 id="4%E3%80%81git%E5%92%8Csvn%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%3F">4、Git和SVN有什么区别?</h5>
        <ul>
            <li>git是分布式版本控制，svn是集中式版本控制（核心区别）</li>
            <li>git相对于svn的优势就是不需要网络即可版本控制</li>
            <li>git把内容按数据方式存储，而svn是按文件</li>
            <li>git可以是公用的，可以分享，svn基本是公司内部才能访问，网外不方便访问</li>
            <li>git不依赖中央服务器，即使服务器有问题也不受影响，svn依赖服务器，一旦服务器有问题就会受影响</li>
            <li>git没有一个全局的版本号，svn有</li>
        </ul>
        <h4
            id="%E5%8D%81%E4%B8%80%E3%80%81B%E7%AB%99%E5%BC%80%E6%BA%90%E8%A7%86%E9%A2%91%E5%A4%A7%E6%B1%87%E6%80%BB%EF%BC%8C%E5%89%8D%E7%AB%AF%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E7%B2%BE%E9%80%9A">
            <a name="t17"></a>十一、B站开源视频大汇总，前端从入门到精通</h4>
        <p><strong>分享一些开源优秀的视频（HTML5，CSS3，JS，Vue2，Vue3，React，微信小程序，uniapp，Electron，JQuery，Ajax，HarmonyOS，webpack，echarts，底层原理）等等</strong>
        </p>
        <p>欢迎大家一起学习进步，学无止境哦~</p>
        <p></p>
        <h5 id="R18LT"><strong>1、web 入门（HTML5+CSS3）</strong></h5>
        <ul>
            <li id="uf88e4ed5">Html5+css：<a href="https://www.bilibili.com/video/BV1kM4y127Li/" rel="nofollow"
                    title="前端Web开发HTML5+CSS3+移动web视频教程，前端web入门首选黑马程序员_哔哩哔哩_bilibili">前端Web开发HTML5+CSS3+移动web视频教程，前端web入门首选黑马程序员_哔哩哔哩_bilibili</a>
            </li>
            <li id="u8fe80f97">web 进阶：<a href="https://www.bilibili.com/video/BV1xq4y1q7jZ/" rel="nofollow"
                    title="黑马程序员web前端进阶教程，前端html5+css3+移动端项目实战（含华为新闻，b站移动端等）_哔哩哔哩_bilibili">黑马程序员web前端进阶教程，前端html5+css3+移动端项目实战（含华为新闻，b站移动端等）_哔哩哔哩_bilibili</a>
            </li>
        </ul>
        <h5 id="umTpf">2、js（JavaScript+jQuery+Ajax）</h5>
        <ul>
            <li id="u87524183">JavaScript：<a href="https://www.bilibili.com/video/BV1Y84y1L7Nn/" rel="nofollow"
                    title="黑马程序员前端JavaScript入门到精通全套视频教程，javascript核心进阶ES6语法、API、js高级等基础知识和实战教程_哔哩哔哩_bilibili">黑马程序员前端JavaScript入门到精通全套视频教程，javascript核心进阶ES6语法、API、js高级等基础知识和实战教程_哔哩哔哩_bilibili</a>
            </li>
            <li id="ua99e5277">DOM BOM：<a href="https://www.bilibili.com/video/BV1k4411w7sV/" rel="nofollow"
                    title="黑马程序员JavaScript核心教程，前端基础教程，JS的DOM BOM操作教程_哔哩哔哩_bilibili">黑马程序员JavaScript核心教程，前端基础教程，JS的DOM
                    BOM操作教程_哔哩哔哩_bilibili</a></li>
            <li id="u52b3bea8">jQuery：<a href="https://www.bilibili.com/video/BV1a4411w7Gx/" rel="nofollow"
                    title="黑马程序员前端基础教程|jQuery网页开发案例精讲_哔哩哔哩_bilibili">黑马程序员前端基础教程|jQuery网页开发案例精讲_哔哩哔哩_bilibili</a></li>
            <li id="u46f02d64">Ajax：<a href="https://www.bilibili.com/video/BV1MN411y7pw/" rel="nofollow"
                    title="黑马程序员前端AJAX入门到实战全套教程，包含学前端框架必会的（ajax+node.js+webpack+git），一套全覆盖_哔哩哔哩_bilibili">黑马程序员前端AJAX入门到实战全套教程，包含学前端框架必会的（ajax+node.js+webpack+git），一套全覆盖_哔哩哔哩_bilibili</a>
            </li>
        </ul>
        <h5 id="HIabi">3、Vue 开发（Vue2+Vue3+实战项目）</h5>
        <ul>
            <li id="u53c3c5cc">Node.js: <a href="https://www.bilibili.com/video/BV1a34y167AZ/" rel="nofollow"
                    title="黑马程序员Node.js全套入门教程，nodejs新教程含es6模块化+npm+express+webpack+promise等_Nodejs实战案例详解_哔哩哔哩_bilibili">黑马程序员Node.js全套入门教程，nodejs新教程含es6模块化+npm+express+webpack+promise等_Nodejs实战案例详解_哔哩哔哩_bilibili</a>
            </li>
            <li id="ud1b60a03">VUE项目实战:<a
                    href="https://www.bilibili.com/video/BV1Vf4y1T7bw/?spm_id_from=333.999.0.0&amp;vd_source=a950413a4c7911db466b800871a025ce"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1Vf4y1T7bw/">https://www.bilibili.com/video/BV1Vf4y1T7bw/</a>
            </li>
            <li id="ud7119cdb">Vue2+Vue3：<a href="https://www.bilibili.com/video/BV1HV4y1a7n4/" rel="nofollow"
                    title="前端最新Vue2+Vue3基础入门到实战项目全套教程，自学前端vue就选黑马程序员，一套全通关！_哔哩哔哩_bilibili">前端最新Vue2+Vue3基础入门到实战项目全套教程，自学前端vue就选黑马程序员，一套全通关！_哔哩哔哩_bilibili</a>
            </li>
            <li id="u5a7b776a">Vue3小兔鲜电商项目：<a href="https://www.bilibili.com/video/BV1Ac411K7EQ/" rel="nofollow"
                    title="黑马程序员前端Vue3小兔鲜电商项目实战，vue3全家桶从入门到实战电商项目一套通关_哔哩哔哩_bilibili">黑马程序员前端Vue3小兔鲜电商项目实战，vue3全家桶从入门到实战电商项目一套通关_哔哩哔哩_bilibili</a>
            </li>
        </ul>
        <h5 id="TjeW0">4、React &amp;&amp;微信小程序开发&amp;&amp;uniapp</h5>
        <ul>
            <li id="u066cdcf1">微信小程序：<a
                    href="https://www.bilibili.com/video/BV1834y1676P/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1834y1676P">https://www.bilibili.com/video/BV1834y1676P</a>
            </li>
            <li id="ubdefa76c"><a href="https://www.bilibili.com/video/BV1834y1676P/uni-app" rel="nofollow"
                    title="uni-app">uni-app</a> : 实战：<a
                    href="https://www.bilibili.com/video/BV1BJ411W7pX/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1BJ411W7pX">https://www.bilibili.com/video/BV1BJ411W7pX</a>
            </li>
            <li id="ud5fa092f"><a href="https://www.bilibili.com/video/BV1Bp4y1379L/React" rel="nofollow"
                    title="React">React</a>：<a
                    href="https://www.bilibili.com/video/BV1wy4y1D7JT/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1wy4y1D7JT/">https://www.bilibili.com/video/BV1wy4y1D7JT/</a>
            </li>
            <li id="ucb79aab4"><a href="https://www.bilibili.com/video/BV1gh411U7JD/TypeScript" rel="nofollow"
                    title="TypeScript">TypeScript</a>：<a href="https://www.bilibili.com/video/BV14Z4y1u7pi/"
                    rel="nofollow"
                    title="黑马程序员前端TypeScript教程，TypeScript零基础入门到实战全套教程_哔哩哔哩_bilibili">黑马程序员前端TypeScript教程，TypeScript零基础入门到实战全套教程_哔哩哔哩_bilibili</a>
            </li>
        </ul>
        <h5 id="rbn7R">5、华为鸿蒙进阶</h5>
        <p id="jZHd7">HarmonyOS：</p>
        <p id="u0595c314"><a
                href="https://developer.huawei.com/consumer/cn/training/path-result?categoryId=101621309955646009"
                rel="nofollow" title="华为开发者学堂">华为开发者学堂</a></p>
        <p id="uc974f76a"><strong>B站鸿蒙2.0</strong>：<a
                href="https://www.bilibili.com/video/BV1LK4y1u7jZ/?spm_id_from=333.788.recommend_more_video.-1&amp;vd_source=ebded8b3137534584af2d6a112cb0da6"
                rel="nofollow" title="黑马程序员鸿蒙开发系统教程，HarmonyOS 2.0鸿蒙应用开发实战教程_哔哩哔哩_bilibili">黑马程序员鸿蒙开发系统教程，HarmonyOS
                2.0鸿蒙应用开发实战教程_哔哩哔哩_bilibili</a></p>
        <h5 id="BIxVr">6、ssr（Nuxt+Next.js）</h5>
        <ul>
            <li id="u101ea933">Nuxt：<a
                    href="https://www.bilibili.com/video/BV13Z4y1T74J/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV13Z4y1T74J/">https://www.bilibili.com/video/BV13Z4y1T74J/</a>
            </li>
            <li id="ub7c8a250">Next.js入门教程：<a
                    href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV13441117KK"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV13441117KK">https://www.bilibili.com/video/BV13441117KK</a>
            </li>
        </ul>
        <h5 id="WMdgv">7、工程化（webpack+vite）</h5>
        <ul>
            <li id="u6352f81d">webpack5：<a
                    href="https://www.bilibili.com/video/BV14T4y1z7sw/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="尚硅谷Webpack5入门到原理（面试开发一条龙）_哔哩哔哩_bilibili">尚硅谷Webpack5入门到原理（面试开发一条龙）_哔哩哔哩_bilibili</a></li>
            <li id="u67fdd7e7">webpack高级：<a
                    href="https://www.bilibili.com/video/BV1cv411C74F/?spm_id_from=333.337.search-card.all.click"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1cv411C74F">https://www.bilibili.com/video/BV1cv411C74F</a>
            </li>
            <li id="uc8977a8d">webpack面试： <a
                    href="https://www.bilibili.com/video/BV1BG4y1K78G/?spm_id_from=autoNext&amp;vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="面试官问：webpack怎么做性能优化？该怎么回答？_哔哩哔哩_bilibili">面试官问：webpack怎么做性能优化？该怎么回答？_哔哩哔哩_bilibili</a></li>
            <li id="u5c6e26db">vite:<a
                    href="https://www.bilibili.com/video/BV1BS4y1P7mU/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1BS4y1P7mU/">https://www.bilibili.com/video/BV1BS4y1P7mU/</a>
            </li>
        </ul>
        <ul>
            <li id="u57e12dcb">Prettier和ESLint使用：<a
                    href="https://gitee.com/link?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV183411r7YK"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV183411r7YK">https://www.bilibili.com/video/BV183411r7YK</a>
            </li>
            <li id="ubbb9d304">ESLint基础入门：<a
                    href="https://gitee.com/link?target=https%3A%2F%2Fspace.bilibili.com%2F390120104%2Fsearch%2Fvideo%3Fkeyword%3DESLint"
                    rel="nofollow"
                    title="https://space.bilibili.com/390120104/search/video?keyword=ESLint">https://space.bilibili.com/390120104/search/video?keyword=ESLint</a>
            </li>
        </ul>
        <h5 id="t8tQu">8、可视化（echarts ）</h5>
        <ul>
            <li id="u00b2ad64">数据可视化项目echarts vue3： <a href="https://www.bilibili.com/video/BV14u411D7qK/"
                    rel="nofollow"
                    title="千锋Echarts+Vue3.0数据可视化项目构建_入门必备前端项目实战教程_哔哩哔哩_bilibili">千锋Echarts+Vue3.0数据可视化项目构建_入门必备前端项目实战教程_哔哩哔哩_bilibili</a>
            </li>
            <li id="u3a830d16">前端可视化大屏: <a
                    href="https://www.bilibili.com/video/BV1v7411R7mp/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1v7411R7mp/">https://www.bilibili.com/video/BV1v7411R7mp/</a>
            </li>
        </ul>
        <h5 id="ZnO6V">9、源码（虚拟DOM和diff算法）</h5>
        <ul>
            <li id="ua7a4bdde">Vue源码解析之虚拟DOM和diff算法: <a
                    href="https://www.bilibili.com/video/BV1v5411H7gZ/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1v5411H7gZ/">https://www.bilibili.com/video/BV1v5411H7gZ/</a>
            </li>
            <li id="ue94be5d8">Vue源码解析之mustache模板引擎 :<a
                    href="https://www.bilibili.com/video/BV1EV411h79m/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1EV411h79m/">https://www.bilibili.com/video/BV1EV411h79m/</a>
            </li>
            <li id="u5dfcdd9c">React18源码级剖析：<a
                    href="https://www.bilibili.com/video/BV1qS4y1m7GY/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1qS4y1m7GY">https://www.bilibili.com/video/BV1qS4y1m7GY</a>
            </li>
        </ul>
        <h5 id="UK8Wv">10、移动App跨端开发（Uni-App）</h5>
        <ul>
            <li id="u20e3c8de">ReactNatvie基础：<a
                    href="https://www.bilibili.com/video/BV1e5411L7VV/?spm_id_from=333.337.search-card.all.click&amp;vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1e5411L7VV/">https://www.bilibili.com/video/BV1e5411L7VV/</a>
            </li>
            <li id="ud19e9ab3">Uni-App从入门到实战：<a
                    href="https://www.bilibili.com/video/BV1BJ411W7pX/?spm_id_from=333.337.search-card.all.click"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1BJ411W7pX/">https://www.bilibili.com/video/BV1BJ411W7pX/</a>
            </li>
            <li id="ua956d758">Flutter：<a
                    href="https://www.bilibili.com/video/BV1S4411E7LY/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1S4411E7LY/">https://www.bilibili.com/video/BV1S4411E7LY/</a>
            </li>
            <li id="u8130f877">鸿蒙项目实操 ：<a href="https://www.bilibili.com/video/BV1bf4y1L7Lj/" rel="nofollow"
                    title="千锋教育_从零编写一个HarmonyOS App_开发鸿蒙项目实操_哔哩哔哩_bilibili">千锋教育_从零编写一个HarmonyOS
                    App_开发鸿蒙项目实操_哔哩哔哩_bilibili</a></li>
        </ul>
        <h5 id="FE9co">11、桌面应用开发（Electron）</h5>
        <ul>
            <li id="u18faf17d">Electron：<a
                    href="https://www.bilibili.com/video/BV1FP4115739/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                    rel="nofollow"
                    title="https://www.bilibili.com/video/BV1FP4115739/">https://www.bilibili.com/video/BV1FP4115739/</a>
            </li>
        </ul>
        <h5 id="JhreY">12、网络知识（网络概述+结构算法）</h5>
        <p id="ue49d52f2">计算机网络概述：<a
                href="https://www.bilibili.com/video/BV1LK4y1b7cj/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                rel="nofollow"
                title="https://www.bilibili.com/video/BV1LK4y1b7cj/">https://www.bilibili.com/video/BV1LK4y1b7cj/</a>
        </p>
        <p id="uf7066fbb">数据结构预算法：<a
                href="https://www.bilibili.com/video/BV1Cz411B7qd/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                rel="nofollow"
                title="https://www.bilibili.com/video/BV1Cz411B7qd/">https://www.bilibili.com/video/BV1Cz411B7qd/</a>
        </p>
        <p id="uc473d26d">10分钟带你了解<a
                href="https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&amp;spm=1001.2101.3001.7020"
                target="_blank" class="hl hl-1"
                data-report-view="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;word\&quot;:\&quot;互联网\&quot;}&quot;}"
                data-report-click="{&quot;spm&quot;:&quot;1001.2101.3001.7020&quot;,&quot;dest&quot;:&quot;https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&amp;spm=1001.2101.3001.7020&quot;,&quot;extra&quot;:&quot;{\&quot;word\&quot;:\&quot;互联网\&quot;}&quot;}"
                data-tit="互联网" data-pretit="互联网">互联网</a>是如何运作的:<a
                href="https://www.bilibili.com/video/BV1Rz4y197Jd/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                rel="nofollow"
                title="https://www.bilibili.com/video/BV1Rz4y197Jd/">https://www.bilibili.com/video/BV1Rz4y197Jd/</a>
        </p>
        <h5 id="LATLr">13、浏览器底层原理</h5>
        <p id="uff2474be">浏览器是如何运作的: <a
                href="https://www.bilibili.com/video/BV1x54y1B7RE/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                rel="nofollow"
                title="https://www.bilibili.com/video/BV1x54y1B7RE/">https://www.bilibili.com/video/BV1x54y1B7RE/</a>
        </p>
        <p id="ucb3fa5e5">JS运行原理: <a
                href="https://www.bilibili.com/video/BV1vh411Z7QG/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                rel="nofollow"
                title="https://www.bilibili.com/video/BV1vh411Z7QG/">https://www.bilibili.com/video/BV1vh411Z7QG/</a>
        </p>
        <p id="u7b84eb63">V8: <a
                href="https://www.bilibili.com/video/BV1zV411z7RX/?vd_source=ebded8b3137534584af2d6a112cb0da6"
                rel="nofollow"
                title="https://www.bilibili.com/video/BV1zV411z7RX/">https://www.bilibili.com/video/BV1zV411z7RX/</a>
        </p>
        <p></p>
        <p></p>
        <p></p>
        <h5
            id="1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7%EF%BC%9F">
        </h5>
    </div>
</body>

</html>